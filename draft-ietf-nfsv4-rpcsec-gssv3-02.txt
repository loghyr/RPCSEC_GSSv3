


NFSv4                                                          T. Haynes
Internet-Draft                                                    NetApp
Intended status: Standards Track                             N. Williams
Expires: October 25, 2012                                   Cryptonector
                                                          April 23, 2012


             Remote Procedure Call (RPC) Security Version 3
                  draft-ietf-nfsv4-rpcsec-gssv3-02.txt

Abstract

   This document specifies version 3 of the Remote Procedure Call (RPC)
   security protocol (RPCSEC_GSS).  This protocol provides for: compound
   authentication of client hosts and users to server (constructed by
   generic composition), channel binding, security label assertions for
   multi-level and type enforcement, privilege assertions, and identity
   assertions.

Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

Status of this Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on October 25, 2012.

Copyright Notice

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal



Haynes & Williams       Expires October 25, 2012                [Page 1]

Internet-Draft                    NFSv4                       April 2012


   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.































Haynes & Williams       Expires October 25, 2012                [Page 2]

Internet-Draft                    NFSv4                       April 2012


Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4
     1.1.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  5
     1.2.  Applications of RPCSEC_GSSv3 . . . . . . . . . . . . . . .  6
   2.  The RPCSEC_GSSv3 protocol  . . . . . . . . . . . . . . . . . .  6
     2.1.  Control messages . . . . . . . . . . . . . . . . . . . . . 12
       2.1.1.  New auth_stat values . . . . . . . . . . . . . . . . . 12
       2.1.2.  Create request . . . . . . . . . . . . . . . . . . . . 12
       2.1.3.  Context handle destruction . . . . . . . . . . . . . . 18
       2.1.4.  List request . . . . . . . . . . . . . . . . . . . . . 18
       2.1.5.  Extensibility  . . . . . . . . . . . . . . . . . . . . 18
   3.  Privileges and identity representation for NFSv4 . . . . . . . 19
   4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 20
   5.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 21
   6.  Normative References . . . . . . . . . . . . . . . . . . . . . 21
   Appendix A.  Acknowledgments . . . . . . . . . . . . . . . . . . . 22
   Appendix B.  RFC Editor Notes  . . . . . . . . . . . . . . . . . . 22
   Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 22
































Haynes & Williams       Expires October 25, 2012                [Page 3]

Internet-Draft                    NFSv4                       April 2012


1.  Introduction

   The original RPCSEC_GSS protocol [2] provided for authentication of
   RPC clients and servers to each other using the Generic Security
   Services Application Programming Interface (GSS-API) [3].  The second
   version of RPCSEC_GSS [4] added support for channel binding [5].

   We find that GSS-API mechanisms are insufficient for communicating
   certain aspects of a client's identity and authority to a server.
   The GSS-API and its mechanisms certainly could be extended to address
   this shortcomming, but it seems be far simpler to address it at the
   application layer, namely, in this case, RPCSEC_GSS.

   We therefore provide a new version of RPCSEC_GSS that allows for the
   following:

   o  compound authentication of the client host and user to the server
      (done by binding of two RPCSEC_GSS handles)

   o  channel binding (even though RPCSEC_GSSv2 provides this also; see
      below)

   o  client-side assertions of authority:

      *  security labels (for multi-level, type enforcement, and other
         labeled security models) [add refs. for labeled security]

      *  application-specific privileges

   o  client-side assertions of identity:

      *  primary client/user identity

      *  supplementary group memberships of the client/user, including
         support for specifying deltas to the membership list as seen on
         the server

   Assertions of labels, privilege and identity are evaluated by the
   server, which may then map the asserted values to other values, all
   according to server-side policy.

   We also add an option for enumerating server-side domains of
   interpretation (DOI), though this seems likely to be unnecessary.

   RPCSEC_GSSv3 is patterned as follows:

   o  a client uses an existing RPCSEC_GSS context handle (of any
      RPCSEC_GSS version) to protect RPCSEC_GSSv3 exchanges (this will



Haynes & Williams       Expires October 25, 2012                [Page 4]

Internet-Draft                    NFSv4                       April 2012


      be termed the "parent" or "outer" handle)

   o  the server issues a "child" RPCSEC_GSSv3 handle, but the
      underlying GSS-API security context for the parent handle is used
      in all subsequent exchanges using the child handle (this works
      because the RPCSEC_GSS handle is included in the integrity
      protected RPCSEC_GSS auth/verifier header for all versions of
      RPCSEC_GSS)

   This means that RPCSEC_GSSv3 depends on RPCSEC_GSS versions 1 and/or
   2 for actual GSS-API security context establishment.  This keeps the
   specification of RPCSEC_GSSv3 simple by avoiding the need to
   duplicate the core functionality of RPCSEC_GSS version 1.

1.1.  Motivation

   The initial motivation for RPCSEC_GSSv3 is to add support for labeled
   security.  Several alternatives to revising RPCSEC_GSS were
   considered:

   a.  application-level protocol extensions, such as new operations for
       the Network File System version 4 (NFSv4) protocol [6];

   b.  a stackable GSS-API pseudo-mechanism that could be composed with
       concrete GSS-API mechanisms to provide both, authentication and
       protected security label assertions;

   c.  per-GSS-API mechanism extensions for transporting security label
       assertions;

   Alternative (c) is not sufficiently general.  One possible benefit of
   (c) might be the ability to have per-{user, label} credentials,
   though that might be difficult to manage (and, anyways, can be
   emulated with regular GSS-API mechanisms through principal naming
   conventions), whereas with the other approaches there is a single
   credential per-user that can be used to assert multiple security
   labels.

   Alternative (a) is not general either, though for the purpose of the
   NFSv4 community it would suffice.  However, a solution at the
   RPCSEC_GSS or GSS-API layers does, or arguably should, fit more
   naturally into most, if not all, NFSv4 implementations.

   Alternative (b) is certainly general enough.  In fact, it is more
   general than the RPCSEC_GSSv3 solution in that it could be used in
   non-RPC protocols that support the use of the GSS-API.  However, the
   RPCSEC_GSSv3 approach is attractively simple.  For example, to pursue
   (b) would likely entail having to specify a framework for mechanism



Haynes & Williams       Expires October 25, 2012                [Page 5]

Internet-Draft                    NFSv4                       April 2012


   composition, as well as GSS-API interfaces to access assertions that
   would typically be very platform-specific.  (The KITTEN WG has
   explored stackable pseudo-mechanisms in the past, but that work is
   currently stagnant.)  It is possible that stackable pseudo-mechanisms
   may materialize in the future; such mechanisms would be usable
   through all versions of RPCSEC_GSS so far.

   As we considered these alternatives we also realized that we needed
   other features that could all be packed into a single solution.  For
   example, the assertion of security label is conceptually equivalent,
   protocol-wise, to assertions of privilege and identity.

   Additionally, assertions need to be verified, and in this case the
   one party that can verify an assertion is the client host, which can
   authenticate to the server using its own credentials.  Yet we want to
   continue authenticating users as well.  This calls for compound
   authentication.

   Finally, because the design of RPCSEC_GSSv3 relies on RPCSEC_GSSv1
   (though v2 can also be used) to do the actual GSS-API security
   context establishment, we add support for channel binding so that
   implementors who have implemented RPCSEC_GSSv1 but not version 2 can
   still provide channel binding without having to implement version 2.
   Channel binding is accomplished in a more simple manner in v3 also.

1.2.  Applications of RPCSEC_GSSv3

   The common uses of RPCSEC_GSSv3, particularly for NFSv4, are expected
   to be:

   a.  labeled security: client-side process label assertion [+
       privilege assertion] + compound client host & user
       authentication;

   b.  compound client host & user authentication [+ privilege
       assertion];

   c.  client-side process credentials assertion [+ privilege assertion]
       as a replacement for AUTH_SYS that is more secure than AUTH_SYS
       while not requiring per-user credentials


2.  The RPCSEC_GSSv3 protocol

   This document contains the External Data Representation (XDR) ([7])
   definitions for the RPCSEC_GSSv3 protocol.

   The XDR description is provided in this document in a way that makes



Haynes & Williams       Expires October 25, 2012                [Page 6]

Internet-Draft                    NFSv4                       April 2012


   it simple for the reader to extract into ready to compile form.  The
   reader can feed this document in the following shell script to
   produce the machine readable XDR description of RPCSEC_GSSv3:

   #!/bin/sh
   grep "^  *///" | sed 's?^  */// ??' | sed 's?^  *///$??'

   I.e. if the above script is stored in a file called "extract.sh", and
   this document is in a file called "spec.txt", then the reader can do:

    sh extract.sh < spec.txt > rpcsec_gss_v3.x

   The effect of the script is to remove leading white space from each
   line, plus a sentinel sequence of "///".

   The XDR description, with the sentinel sequence follows:

      ///  /*
      ///   * Copyright (c) 2011 IETF Trust and the persons
      ///   * identified as the document authors. All rights
      ///   * reserved.
      ///   *
      ///   * The document authors are identified in [RFC2203],
      ///   * [RFC5403], and [RFCxxxx].
      ///   *
      ///   * Redistribution and use in source and binary forms,
      ///   * with or without modification, are permitted
      ///   * provided that the following conditions are met:
      ///   *
      ///   * o Redistributions of source code must retain the above
      ///   *   copyright notice, this list of conditions and the
      ///   *   following disclaimer.
      ///   *
      ///   * o Redistributions in binary form must reproduce the
      ///   *   above copyright notice, this list of
      ///   *   conditions and the following disclaimer in
      ///   *   the documentation and/or other materials
      ///   *   provided with the distribution.
      ///   *
      ///   * o Neither the name of Internet Society, IETF or IETF
      ///   *   Trust, nor the names of specific contributors, may be
      ///   *   used to endorse or promote products derived from this
      ///   *   software without specific prior written permission.
      ///   *
      ///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
      ///   *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
      ///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      ///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS



Haynes & Williams       Expires October 25, 2012                [Page 7]

Internet-Draft                    NFSv4                       April 2012


      ///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
      ///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
      ///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
      ///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
      ///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
      ///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
      ///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      ///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
      ///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
      ///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
      ///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      ///   */
      ///
      ///  /*
      ///   * This code was derived from [RFC2203]. Please
      ///   * reproduce this note if possible.
      ///   */
      ///
      ///  /*
      ///   * rpcsec_gss_v3.x
      ///   */
      ///
      ///  enum rpc_gss_service_t {
      ///          /* Note: the enumerated value for 0 is reserved. */
      ///          rpc_gss_svc_none         = 1,
      ///          rpc_gss_svc_integrity    = 2,
      ///          rpc_gss_svc_privacy      = 3,
      ///          rpc_gss_svc_channel_prot = 4
      ///  };
      ///
      ///  enum rpc_gss_proc_t {
      ///           RPCSEC_GSS_DATA          = 0,
      ///           RPCSEC_GSS_INIT          = 1,
      ///           RPCSEC_GSS_CONTINUE_INIT = 2,
      ///           RPCSEC_GSS_DESTROY       = 3,
      ///           RPCSEC_GSS_BIND_CHANNEL  = 4
      ///  };
      ///
      ///  struct rpc_gss_cred_vers_1_t {
      ///          rpc_gss_proc_t    gss_proc; /* control procedure */
      ///          unsigned int      seq_num;  /* sequence number */
      ///          rpc_gss_service_t service;  /* service used */
      ///          opaque            handle<>; /* context handle */
      ///  };
      ///
      ///  enum rpc_gss3_proc_t {
      ///          RPCSEC_GSS3_DATA = 0,
      ///          RPCSEC_GSS3_LIST = 5,



Haynes & Williams       Expires October 25, 2012                [Page 8]

Internet-Draft                    NFSv4                       April 2012


      ///          RPCSEC_GSS3_CREATE = 6,
      ///          RPCSEC_GSS3_DESTROY = 7
      ///  };
      ///
      ///  struct rpc_gss_cred_vers_3_t {
      ///          rpc_gss3_proc_t         gss_proc;
      ///          unsigned int            seq_num;
      ///          rpc_gss_service_t       service;
      ///          opaque                  handle<>;
      ///          unsigned int            handle_version;
      ///  };
      ///
      ///  const RPCSEC_GSS_VERS_1 = 1;
      ///  const RPCSEC_GSS_VERS_2 = 2;
      ///  const RPCSEC_GSS_VERS_3 = 3; /* new */
      ///
      ///  union rpc_gss_cred_t switch (unsigned int rgc_version) {
      ///  case RPCSEC_GSS_VERS_1:
      ///  case RPCSEC_GSS_VERS_2:
      ///          rpc_gss_cred_vers_1_t rgc_cred_v1;
      ///  case RPCSEC_GSS_VERS_3: /* new */
      ///          rpc_gss_cred_vers_3_t rgc_cred_v3;
      ///  };
      ///
      ///  const MAXSEQ = 0x80000000;
      ///
      ///  struct rpc_gss3_extension {
      ///          int     type;
      ///          bool    critical;
      ///          opaque  data<>;
      ///  };
      ///
      ///  struct rpc_gss3_gss_binding {
      ///          unsigned int    vers;
      ///          opaque          handle<>;
      ///          opaque          nonce<>;
      ///          opaque          mic<>;
      ///  };
      ///
      ///  typedef opaque rpc_gss3_chan_binding<>;
      ///
      ///  typedef opaque rpc_gss3_doi<>;
      ///  struct rpc_gss3_label {
      ///          rpc_gss3_doi    doi;
      ///          opaque          label<>;
      ///  };
      ///
      ///  typedef opaque rpc_gss3_privs<>;



Haynes & Williams       Expires October 25, 2012                [Page 9]

Internet-Draft                    NFSv4                       April 2012


      ///
      ///  typedef opaque rpc_gss3_name<>;
      ///
      ///  typedef rpc_gss3_name rpc_gss3_group_list<>;
      ///  struct rpc_gss3_id {
      ///          rpc_gss3_name         *username;
      ///          rpc_gss3_group_list   *groups;
      ///          rpc_gss3_group_list   groups_add;
      ///          rpc_gss3_group_list   groups_remove;
      ///  };
      ///
      ///  enum rpc_gss3_assertion_type {
      ///          LABEL = 0,
      ///          PRIVS = 1,
      ///          IDENTITY = 2
      ///  };
      ///
      ///  union rpc_gss3_assertion_u
      ///        switch (rpc_gss3_assertion_type atype) {
      ///  case LABEL:
      ///          rpc_gss3_label  label;
      ///  case PRIVILEGES:
      ///          rpc_gss3_privs  privs;
      ///  case IDENTITY:
      ///          rpc_gss3_id     id;
      ///  default:
      ///          opaque          ext<>;
      ///  };
      ///
      ///  struct rpc_gss3_assertion {
      ///          bool                    critical;
      ///          rpc_gss3_assertion_u    assertion;
      ///  };
      ///
      ///  struct rpc_gss3_create_args {
      ///          rpc_gss3_gss_binding    *compound_binding;
      ///          rpc_gss3_chan_binding   *chan_binding_mic;
      ///          rpc_gss3_assertion      assertions<>;
      ///          rpc_gss3_extension      extensions<>;
      ///  };
      ///
      ///  struct rpc_gss3_create_res {
      ///          opaque                  handle<>;
      ///          rpc_gss3_chan_binding   *chan_binding_mic;
      ///          rpc_gss3_assertion      granted_assertions<>;
      ///          rpc_gss3_assertion      assertions_denied<>;
      ///          rpc_gss3_assertion      assertions_not_understood<>;
      ///          rpc_gss3_assertion      server_assertions<>;



Haynes & Williams       Expires October 25, 2012               [Page 10]

Internet-Draft                    NFSv4                       April 2012


      ///          rpc_gss3_extension      extensions<>;
      ///  };
      ///
      ///  enum rpc_gss3_list_item {
      ///          DOI = 0,
      ///          PRIV = 1,
      ///          PRIV_GROUP = 2
      ///  };
      ///
      ///  struct rpc_gss3_list_args {
      ///          rpc_gss3_list_item      list_what<>;
      ///  };
      ///
      ///  union rpc_gss3_list_item_u
      ///        switch (rpc_gss3_list_item itype) {
      ///  case DOI:
      ///          rpc_gss3_doi    dois<>;
      ///  case PRIV:
      ///          string          privs<>;
      ///  case PRIV_GROUP:
      ///          string          priv_groups<>;
      ///  default:
      ///          opaque          ext<>;
      ///  };
      ///
      ///  typedef rpc_gss3_list_item_u rpc_gss3_list_res<>;

   The rpc_gss_cred_vers_3_t type is used in much the same way that
   rpc_gss_cred_vers_1_t is used in RPCSEC_GSSv1, that is: as the arm of
   the rpc_gss_cred_t discriminated union corresponding to version 3
   (RPCSEC_GSS_VERS_3).  It differs from rpc_gss_cred_vers_1_t in that:

   a.  the values for gss_proc corresponding to control messages are
       different,

   b.  the presence of a field indicating the version of RPCSEC_GSS used
       to established the context handle used, if any.

   RPC data messages using RPCSEC_GSSv3 context handles differ from
   RPCSEC_GSSv1 only in that the version number used MUST be '3' instead
   of '1' and, as described above, in that there is one more field in
   the RPCSEC_GSS header to name the version of RPCSEC_GSS used to
   establish the context handle used to protect this message.  All other
   protocol elements from RPCSEC_GSSv1-protected RPC data messages MUST
   remain the same in v3 as in v1.

   RPCSEC_GSSv3 control messages are the same as RPCSEC_GSSv3 data
   messages, but with a gss_proc value that indicates a control message



Haynes & Williams       Expires October 25, 2012               [Page 11]

Internet-Draft                    NFSv4                       April 2012


   is contained in the data payload.

2.1.  Control messages

   There are two RPCSEC_GSSv3 control messages: RPCSEC_GSS3_CREATE and
   RPCSEC_GSS3_LIST.

   The client MUST use one of the following security services to protect
   any RPCSEC_GSSv3 control message:

   o  rpc_gss_svc_channel_prot (see RPCSEC_GSSv2)

   o  rpc_gss_svc_integrity

   o  rpc_gss_svc_privacy

   Specifically the client MUST NOT use rpc_gss_svc_none.

2.1.1.  New auth_stat values

   RPCSEC_GSSv3 requires the addition of several values to the auth_stat
   enumerated type definition:

              enum auth_stat {
                      ...
                      /*
                       * RPCSEC_GSS errors
                       */
                      RPCSEC_GSS3_COMPOUND_PROBEM = <>,
                      RPCSEC_GSS3_LABEL_PROBLEM = <>,
                      RPCSEC_GSS3_IDENTITY_PROBLEM = <>
                      RPCSEC_GSS3_UNKNOWN_ASSERTION = <>
                      RPCSEC_GSS3_UNKNOWN_EXTENSION = <>
                      RPCSEC_GSS3_UNKNOWN_MESSAGE = <>
              };

   XXX: fix above into YYY.  All the entries are TBD...

2.1.2.  Create request

   The RPCSEC_GSS3_CREATE call message consists of inputs to bind into a
   new RPCSEC_GSSv3 handle.  The context handle used to protect the
   RPCSEC_GSS3_CREATE call message is termed the "parent" (or "outer")
   handle.  The reply to this message consists of either an error or a
   new RPCSEC_GSSv3 handle, termed the "child" handle.

   All uses of a child context handle MUST use the GSS-API security
   context associated with the parent context handle of the



Haynes & Williams       Expires October 25, 2012               [Page 12]

Internet-Draft                    NFSv4                       April 2012


   RPCSEC_GSS3_CREATE request that produced the child context handle.
   The child context, however, has its own sequence number space and
   window, distinct from that of the parent.

   As described in the introduction, the RPCSEC_GSS3_CREATE call message
   binds one or more items of several kinds into a new RPCSEC_GSSv3
   context handle:

   o  another RPCSEC_GSS (version 1, 2, or 3) context handle

   o  a channel binding

   o  authorization assertions (label, privileges)

   o  identity assertions

   Servers MUST either ignore, reject or apply policy to the
   authorization and identity assertions.  Policies should take into
   account the identity of the client and/or user as authenticated via
   the GSS-API.  Server implementation and policy MAY result in labels,
   privileges and identities being mapped to concepts and values that
   are local to the server.

2.1.2.1.  Compound authentication

   RPCSEC_GSSv3 allows for compound authentication of client hosts and
   users to servers.  This is done by using an integrity protected
   RPCSEC_GSSv3 message of RPCSEC_GSS3_CREATE type which includes a
   reference to the context handle to bind, a nonce and a MIC of that
   nonce using the GSS-API security context associated with the named
   context handle.  We'll term the two context handles "parent" (or
   "outer") and "inner," and the resulting context handle the "child"
   handle, where the outer context handle is the context handle
   providing integrity protection to the RPCSEC_GSS3_CREATE message, and
   the inner context handle is the one referenced via the
   compound_binding field of the RPCSEC_GSS3_CREATE arguments structure
   (rpc_gss3_create_args).

   All uses of a child context handle that is bound to an inner context
   MUST be treated as speaking for the initiator principal (as modified
   by any assertions in the RPCSEC_GSS3_CREATE message) of the inner
   context handle's GSS-API security context.

   This feature is needed, for example, when a client wishes to use
   authority assertions that the server may only grant if a user and a
   client are authenticated together to the server.  Thus a server may
   refuse to grant requested authority to a user acting alone (e.g., via
   an unprivileged user-space program), but may grant requested



Haynes & Williams       Expires October 25, 2012               [Page 13]

Internet-Draft                    NFSv4                       April 2012


   authority to a client acting on behalf of a user if the server trusts
   the client.

   It is assumed that an unprivileged user-space program would not have
   access to client host credentials needed to establish a GSS-API
   security context authenticating the client to the server, therefore
   an unprivileged user-space program could not create an RPCSEC_GSSv3
   RPCSEC_GSS3_CREATE message that successfully binds a client and a
   user security context.

   Clients using RPCSEC_GSS context binding MUST use, as the outer
   context handle, an RPCSEC_GSS context handle that corresponds to a
   GSS-API security context that authenticates the client host, and for
   the inner context handle it SHOULD use a context handle to
   authenticates a user.  The reverse (outer handle authenticates user,
   inner authenticates client) MUST NOT be used.  Other compounds might
   eventually make sense.

   An RPCSEC_GSSv3 context handle that is bound to another RPCSEC_GSS
   context MUST be treated by servers as authenticating the GSS-API
   initiator principal authenticated by the inner context handle's GSS-
   API security context.  This principal may be mapped to a server-side
   notion of user or principal as modified by any identity assertions by
   the client in the same RPCSEC_GSS3_CREATE request that the server
   accepts.

2.1.2.2.  Channel binding

   RPCSEC_GSSv3 provides a different way to do channel binding than
   RPCSEC_GSSv2.  Specifically:

   a.  RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing,
       established context handles rather than providing a different RPC
       security flavor for establishing context handles,

   b.  channel bindings data are not hashed because the community now
       agrees that it is the secure channel's responsibility to produce
       channel bindings data of manageable size.

   (a) is useful in keeping RPCSEC_GSSv3 simple in general, not just for
   channel binding. (b) is useful in keeping RPCSEC_GSSv3 simple
   specifically for channel binding.

   Channel binding is accomplished as follows.  The client prefixes the
   channel bindings data octet string with the channel type as described
   in [5], then the client calls GSS_GetMIC() to get a MIC of resulting
   octet string, using the outer RPCSEC_GSS context handle's GSS-API
   security context.  The MIC is then placed in the chan_binding_mic



Haynes & Williams       Expires October 25, 2012               [Page 14]

Internet-Draft                    NFSv4                       April 2012


   field of RPCSEC_GSS3_CREATE arguments (rpc_gss3_create_args).

   If the chan_binding_mic field of the arguments of a
   RPCSEC_GSS3_CREATE control message is set, then the server MUST
   verify the client's channel binding MIC if the server supports this
   feature.  If channel binding verification succeeds then the server
   MUST generate a new MIC of the same channel bindings and place it in
   the chan_binding_mic field of the RPCSEC_GSS3_CREATE results.  If
   channel binding verification fails or the server doesn't support
   channel binding then the server MUST indicate this in its reply by
   not including a chan_binding_mic value (chan_binding_mic is an
   optional field).

   The client MUST verify the result's chan_binding_mic value, if the
   server included it, by calling GSS_VerifyMIC() with the given MIC and
   the channel bindings data (including the channel type prefix).  If
   client-side channel binding verification fails then the client MUST
   call RPCSEC_GSS3_DESTROY.  If the client requested channel binding
   but the server did not include a chan_binding_mic field in the
   results, then the client MAY continue to use the resulting context
   handle as though channel binding had never been requested, otherwise
   (if the client really wanted channel binding) it MUST call
   RPCSEC_GSS3_DESTROY.

   As per-RPCSEC_GSSv2:

   o  "Once a successful [channel binding] procedure has been performed
      on an [RPCSEC_GSSv3] context handle, the initiator's
      implementation may map application requests for rpc_gss_svc_none
      and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials.
      And if the secure channel has privacy enabled, requests for
      rpc_gss_svc_privacy can also be mapped to
      rpc_gss_svc_channel_prot."

   o  ...

   Any RPCSEC_GSSv3 context handle that has been bound to a secure
   channel in this way SHOULD be used only with the
   rpc_gss_svc_channel_prot, and SHOULD NOT be used with
   rpc_gss_svc_none nor rpc_gss_svc_integrity -- if the secure channel
   does not provide privacy protection then the client MAY use
   rpc_gss_svc_privacy where privacy protection is needed or desired.

2.1.2.3.  Label assertions

   RPCSEC_GSSv3 clients MAY assert a security label in some DOI by
   binding this assertion into an RPCSEC_GSSv3 context handle.  This is
   done by including an assertion of type rpc_gss3_label in the



Haynes & Williams       Expires October 25, 2012               [Page 15]

Internet-Draft                    NFSv4                       April 2012


   'assertions' field (discriminant: 'LABEL') of the RPCSEC_GSS3_CREATE
   arguments to the desired DOI and label.

   Label encoding is specific to each DOI and not described herein.  DOI
   encoding is TBD [fill in...  Solaris uses integers to name DOIs, and
   there is an IANA registry of DOIs as 32-bit integers, and IPsec
   (whence the IANA registry) and CALIPSO use 32-bit integers for DOIs
   as well.  So a 32-bit unsinged integer seems to be the way to go.
   Add references... -Nico]

   If a label itself requires privacy protection (i.e., that the user
   can assert that label is a secret) then the client MUST use the
   rpc_gss_svc_privacy protection service for the RPCSEC_GSS3_CREATE
   request or, if the parent handle is bound to a secure channel that
   provides privacy protection, rpc_gss_svc_channel_prot.

   If a client wants to ensure that the server understands the asserted
   label then it MUST set the 'critical' field of the label assertion to
   TRUE, otherwise it MUST set it to FALSE.

   Servers that don't support labeling MUST ignore non-critical label
   assertions.  Servers that don't support the requested DOI MUST either
   ignore non-critical label assertions or map them to a suitable label
   in a supported DOI.  Servers that don't support labeling or don't
   support the requested DOI MUST return an error if the label request
   is critical.  Servers that support labeling in the requested DOI MAY
   map the requested label to different label as a result of server-side
   policy evaluation.

2.1.2.4.  Privilege assertions

   Privilege assertions are similar to label assertions, except that
   there is no DOI, and the privileges supported are specified by the
   RPC application.

   Privileges are encoded US-ASCII strings containing comma-separated
   privilege names, as well as up to one privilege group name and zero
   or more exclusions, where each exclusion is a privilege name or
   privilege group name prefixed with an exclamation point.  Two special
   privilege group names are defined here: "all" (which represents all
   possible privileges) and "basic" (which represents privileges
   normally granted to all users).

   RPC applications that wish to use this facility must define the set
   of known privileges, and must specify which privileges are in the
   "basic" privilege group.  For example, NFSv4 might specify privileges
   for reading, writing, chowning, linking, etcetera.




Haynes & Williams       Expires October 25, 2012               [Page 16]

Internet-Draft                    NFSv4                       April 2012


2.1.2.5.  Identity assertions

   Identity assertions can be used either to modify the set of groups
   assigned on the server-side to a given user (authenticated by the
   GSS-API) or to implement an AUTH_SYS-like [4].  In the latter case
   the client specifies at least a user-name and possibly groups that it
   thinks the user belongs to.

   Clients may set a username, a group list, and/or lists of groups to
   be added or removed from the group list that the server would
   normally use for the given user.

   The server MUST decide whether to accept identity assertions by
   applying local policy.  Such policies is not described herein.
   Example policies:

   o  "always accept identity assertions"

   o  "always accept identity assertions where the identities are
      understood"

   o  "accept identity assertions ... only from trusted clients" (where
      the identity of the client is taken from the initiator principal
      of the outer context handle's GSS-API security context, or from
      the network address of the client...)

   o  "accept identity assertions ... only from trusted clients where
      IPsec policy protects this application's packet flows between the
      clients and this server"

   o  "accept only removals of groups from a user's group membership
      list as determined by the server"

   o  "never accept identity assertions"

   o  etcetera

   Clients may mark an identity assertion as being critical, in which
   case the server MUST respond with an error if the server does not
   accept the identity assertion as-is.

   The representation of users and groups is not given here, but is left
   to the application.  It is expected that RPCSEC_GSSv3 identity
   assertions in the context of the NFSv4 application would consist of
   NFSv4 user and group representations as used on the wire in NFSv4
   access control lists (ACLs).





Haynes & Williams       Expires October 25, 2012               [Page 17]

Internet-Draft                    NFSv4                       April 2012


2.1.2.6.  Server assertions

   Servers MAY inform clients of assertions were granted by setting the
   'granted_assertions' field of the RPCSEC_GSS3_CREATE reply.

   The protocol provides a field ('server_assertions') for servers to
   make assertions about themselves.  At this time there is not much use
   for this field, though servers MAY assert a single security label,
   indicating that all contents on the server is at that label.  The
   client MUST, of course, either evaluate or ignore any server-side
   assertions.

2.1.3.  Context handle destruction

   The RPCSEC_GSS3_DESTROY procedure is the same as for RPCSEC_GSSv1,
   but with the version 3 header.

2.1.4.  List request

   The RPCSEC_GSS3_LIST call message consists of a single integer
   indicating what should be listed, and the reply consists of an error
   or the requested list.

   The client may list DOIs, privilege names, or privilege group names.

   The result is an opaque octet string containing a list of DOIs
   [encoding TBD] or a US-ASCII string containing a comma-separated list
   of privilege names or privilege group names.

2.1.5.  Extensibility

   Assertion types may be added in the future by adding arms to the
   'rpc_gss3_assertion_u' union.  Every assertion has a 'critical' flag
   that can be used to indicate criticality.

   New fields may be added through the 'extensions' typed hole.  All
   such extensions have a 'critical' flag.

   New message types may be added.

   Clients receiving unknown critical server assertions MUST destroy the
   established RPCSEC_GSSv3 context handle.  Servers receiving unknown
   critical client assertions or unknown RPCSEC_GSS_v3 extensions MUST
   return an error.

   There is no IANA or other registry for RPCSEC_GSSv3 extensions.  All
   extensions MUST be done by IETF Protocol Action.




Haynes & Williams       Expires October 25, 2012               [Page 18]

Internet-Draft                    NFSv4                       April 2012


3.  Privileges and identity representation for NFSv4

   The representation of users and groups for use in identity assertions
   in RPCSEC_GSSv3 SHALL be the same as the user and group
   representations used by NFSv4 for access control list subjects on the
   wire, cast as an octet string ("opaque").

   The following privileges are defined for use with the NFSv4 protocol:

   file_chown  Generally allows the caller to change a file's owner
      regardless of who owns the file.

   file_chown_self  Generally allows the caller to change the owner of a
      file it owns.

   file_dac_execute  Generally allows the caller to read any file for
      execution.

   file_dac_read  Generally allows the caller to read any file or
      directory.

   file_dac_search  Generally allows the caller to search any directory.

   file_dac_write  Generally allows the caller to write to any file (or
      create/delete/link objects in directories).

   file_link_any  Generally allows the caller to create hardlinks to
      files not owned by the caller.

   file_owner  Generally allows the caller to modify the access,
      modification and other timestamps of a filesystem object, as well
      as its permissions and ACL.

   file_setid  Generally allows the caller to set the set-user-ID and
      set-group-ID bits of a file.

   file_downgrade_sl  Generally allows the caller to downgrade the
      security label of a filesystem object.

   file_update_sl  Generally allows the caller to upgrade the security
      label of a filesystem object.

   [What about NFSv3?  The representation of privs would be the same for
   v3 as for v4, though there'd be no privs for dealing with labels
   (file_downgrade_sl and file_update_sl).  And the representation of
   users/groups would NFSv3's representation thereof.  But should we
   bother to specify this? -Nico]




Haynes & Williams       Expires October 25, 2012               [Page 19]

Internet-Draft                    NFSv4                       April 2012


   [Also, this is derived from Solaris' notion of privileges.  We should
   look at how well this scheme relates to other operating systems as
   NFSv4 clients and servers. -Nico]

   The contents of the 'basic' privilege set is not defined herein.
   Note that 'file_link_any' and 'file_chown_self' may be present in the
   server's notion of the basic privilege set.

   The NFSv4-specific privileges may be limited by the server in ways
   not specified above.  For example, the server may deny access for
   certain operations that would normally be granted given the granted
   assertion of a given privilege (e.g., "no one may write to files
   owned by such and such user"), or the server may require that all
   privileges be asserted (and granted, of course) in order to allow
   certain operations (e.g., "all privileges are required in order to
   write to files owned by such and such user, not just
   file_dac_write").


4.  Security Considerations

   This entire document deals with security issues.

   The RPCSEC_GSSv3 protocol allows for client-side assertions of data
   that is relevant to server-side authorization decisions.  These
   assertions must be evaludated by the server in the context of whether
   the client and/or user are authenticated, whether compound
   authentication was used, whether the client is trusted, what ranges
   of assertions are allowed for the client and the user (separately or
   together), and any relevant server-side policy.

   The security semantics of assertions carried by RPCSEC_GSSv3 are
   application protocol-specific.

   RPCSEC_GSSv3 supports a notion of critical assertions (and
   extensions), but there's no need for peers to tell each other what
   assertions were granted, or what they were mapped to.

   Note that RPSEC_GSSv3 is not a complete solution for labeling: it
   conveys the labels of actors, but not the labels of objects.  RPC
   application protocols may require extending in order to carry object
   label information.

   The RPCSEC_GSSv3 protocol also provides for a replacement of the old
   AUTH_SYS RPC authentication flavor.  AUTH_SYS relies on "privileged
   port numbers" for "authentication," and was quite limited in what
   assertions it supported and incompatible with NFSv4 representations
   of identity.  To replace AUTH_SYS with RPCSEC_GSSv3 simply use a GSS-



Haynes & Williams       Expires October 25, 2012               [Page 20]

Internet-Draft                    NFSv4                       April 2012


   API mechanism to authenticate the client (but not the user) and let
   the client assert the user's identity.  This is more secure than
   AUTH_SYS in that at least the client can be strongly authenticated
   using GSS-API mechanisms, and it is more functional than AUTH_SYS in
   that identity representations are defined by the application layer.

   It is possible that a GSS-API mechanism that does not provide any
   security services could be created so as to make it possible to
   replace AUTH_SYS with RPCSEC_GSSv3 while retaining the same
   privileged port semantics.  Such a mechanism is out of scope for this
   document and would have its own security considerations.

   There may be interactions with NFSv4's callback security scheme and
   NFSv4.1's GSS-API "SSV" mechanisms.  Specifically, the NFSv4 callback
   scheme requires that the server initiate GSS-API security contexts,
   which does not work well in practice, and in the context of client-
   side processes running as the same user but with different privileges
   and security labels the NFSv4 callback security scheme seems
   particularly unlikely to work well.  NFSv4.1 has the server use an
   existing, client-initiated RPCSEC_GSS context handle to protect
   server-initiated callback RPCs.  The NFSv4.1 callback security scheme
   lacks all the problems of the NFSv4 scheme, however, it is important
   that the server pick an appropriate RPCSEC_GSS context handle to
   protect any callbacks.  Specifically, it is important that the server
   use RPCSEC_GSS context handles which authenticate the client to
   protect any callbacks relating to server state initiated by RPCs
   protected by RPCSEC_GSSv3 contexts.  [Add text about interaction with
   GSS-SSV...]

   [Anything else?]


5.  IANA Considerations

   This section uses terms that are defined in [8].

   There are no IANA considerations in this document.  TBDs in this
   document will be assigned by the ONC RPC registrart (which is not
   IANA, XXX: verify).


6.  Normative References

   [1]  Bradner, S., "Key words for use in RFCs to Indicate Requirement
        Levels", March 1997.

   [2]  Eisler, M., Chiu, A., and L. Ling, "RPCSEC_GSS Protocol
        Specification", RFC 2203, September 1997.



Haynes & Williams       Expires October 25, 2012               [Page 21]

Internet-Draft                    NFSv4                       April 2012


   [3]  Linn, J., "Generic Security Service Application Program
        Interface Version 2, Update 1", RFC 2743, January 2000.

   [4]  Srinivasan, R., "RPC: Remote Procedure Call Protocol
        Specification Version 2", RFC 1831, August 1995.

   [5]  Williams, N., "On the Use of Channel Bindings to Secure
        Channels", RFC 5056, November 2007.

   [6]  Haynes, T. and D. Noveck, "Network File System (NFS) version 4
        Protocol", draft-ietf-nfsv4-rfc3530bis-09 (Work In Progress),
        March 2011.

   [7]  Eisler, M., "XDR: External Data Representation Standard",
        RFC 4506, May 2006.

   [8]  Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
        Considerations Section in RFCs", BCP 26, RFC 5226, May 2008.

   [9]  Shepler, S., Eisler, M., and D. Noveck, "Network File System
        (NFS) Version 4 Minor Version 1 Protocol", RFC 5661,
        January 2010.


Appendix A.  Acknowledgments


Appendix B.  RFC Editor Notes

   [RFC Editor: please remove this section prior to publishing this
   document as an RFC]

   [RFC Editor: prior to publishing this document as an RFC, please
   replace all occurrences of RFCTBD10 with RFCxxxx where xxxx is the
   RFC number of this document]


Authors' Addresses

   Thomas Haynes
   NetApp
   9110 E 66th St
   Tulsa, OK  74133
   USA

   Phone: +1 918 307 1415
   Email: thomas@netapp.com




Haynes & Williams       Expires October 25, 2012               [Page 22]

Internet-Draft                    NFSv4                       April 2012


   Nico Williams
   cryptonector.com
   13115 Tamayo Dr
   Austin, TX  78729
   USA

   Email: nico@cryptonector.com












































Haynes & Williams       Expires October 25, 2012               [Page 23]

