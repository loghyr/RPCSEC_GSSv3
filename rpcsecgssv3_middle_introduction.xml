<!-- Copyright (C) The IETF Trust (2012) -->
<!-- Copyright (C) The Internet Society (2012) -->
<section anchor="sec:intro" title="Introduction">
  <t>
    The original RPCSEC_GSS protocol <xref target="RFC2203" /> provided for
    authentication of RPC clients and servers to each other using the
    Generic Security Services Application Programming Interface (GSS-API)
    <xref target="RFC2743" />.  The second version of
    RPCSEC_GSS <xref target="RFC1831" />  added support
    for channel bindings <xref target="RFC5056" />.
  </t>

  <t>
    We find that GSS-API mechanisms are insufficient for communicating
    certain aspects of a client's authority to a server.
    The GSS-API and its mechanisms certainly could be extended to address
    this shortcoming, but it seems be far simpler to address it at the
    application layer, namely, in this case, RPCSEC_GSS.
  </t>

  <t>
    The motivation for RPCSEC_GSSv3 is to add support for labeled security
    and server-side copy for NFSv4 (see <xref target='ref:nfsv4.2' /> and
    <xref target='ref:lnfs_req' />). Both of these features require assertions
    of authority from the client.
  </t>

  <t>
    Assertions need to be verified.
    One party that can verify an assertion is the client host, which can
    authenticate to the server using its own credentials. We can also
    require users to verify an assertion as well.  This calls
    for compound authentication.
  </t>


  <t>
   Because the design of RPCSEC_GSSv3 relies on either RPCSEC_GSS version 1
   (though version 2 can be used) to do the actual GSS-API security context
   establishment, we add support for channel binding so that implementors
   who have implemented RPCSEC_GSS version 1 but not version 2 can provide
   a (simplified) channel binding implementation using RPCSEC_GSSv3. 
  </t>

  <t>
    We therefore describe a new version of RPCSEC_GSS that allows for the
    following:

    <list style='symbols'>
      <t>
        Client-side assertions of authority:

        <list style='symbols'>
          <t>
            Security labels for multi-level, type enforcement, and other
            labeled security models. See <xref target='ref:rh_mls' />,
            <xref target='DTOS' />, <xref target='SENFSV3' />,
            <xref target='ref:nfsv4.2' /> and <xref target='ref:lnfs_req' />.
          </t>
          <t>
            Application-specific structured privileges. For an example
            see server-side copy <xref target='ref:nfsv4.2' />.
          </t>
      <t>
        Compound authentication of the client host and user to the server
        done by binding two RPCSEC_GSS handles.
      </t>

      <t>
        Simplified channel binding. 
      </t>
        </list>
      </t>
    </list>
  </t>

  <t>
    Assertions of labels and privileges are evaluated by the
    server, which may then map the asserted values to other values, all
    according to server-side policy.
  </t>

  <t>
    We add an option for enumerating server supported label format specifiers
    (LFS).  The LFS and Label Format Registry are described in detail
    in <xref target='ref:lfsreg' />.
  </t>

  <t>
    RPCSEC_GSSv3 is patterned as follows:

    <list style='symbols'>
      <t>
        A client uses an existing RPCSEC_GSSv1 (or RPCSEC_GSSv2) context
        handle to protect RPCSEC_GSSv3 exchanges (this will be termed the
        "parent" handle)
      </t>

      <t>
        The server issues a "child" RPCSEC_GSSv3 handle which uses the
        underlying GSS-API security context of the parent handle 
        in all subsequent exchanges that uses the child handle.
      </t>

      <t>
        The child handle, however, has its own sequence number space
        distinct from that of the parent.
      </t>
    </list>
  </t>
      <t>
        <cref anchor='AI1' source='AA'>
	 I removed the "child has a window distinct from that of the parent"
         because
         RFC2203 states: "   In a successful response, the seq_window field
         is set to the sequence window length supported by the server for
         this context.  This window specifies the maximum number of client
         requests that may be outstanding for this context."
         If we want a distinct window, we will need to add that to the
         rpc_gss3_create_res so that the server can set it.
         I see no point - just use the parent window.
        </cref>
      </t>

      <t>
        <cref anchor='AI2' source='AA'>
         RFC2203 states that when data integrity is used, the seq_num in the
         rpc_gss_data_t must be the same as in the credential. This means that
         using data integrity with GSS3 context's can not simply construct it
         using the parent context as the seq_num must be from the GSS3 context. 
        </cref>
      </t>

  <t>
    This means that RPCSEC_GSSv3 depends on RPCSEC_GSS versions 1 and/or
    2 for actual GSS-API security context establishment.  This keeps the
    specification of RPCSEC_GSSv3 simple by avoiding the need to
    duplicate the core functionality of RPCSEC_GSS version 1.
  </t>

  <section anchor="ss:aor" title="Applications of RPCSEC_GSSv3">

    <t>
      The common uses of RPCSEC_GSSv3, particularly for
      NFSv4 <xref target='ref:nfsv4.2' />, are expected to be:

      <list style="letters">
        <t>
          labeled security: client-side process label assertion [+
          privilege assertion] + compound client host & user
          authentication;
        </t>
        <t>
          compound client host & user authentication [+
          critical structured privilege assertions] used in inter-server
          server-side copy;
        </t>
      </list>
    </t>

    <t>
      Labeled NFS (see Section 8 of <xref target='ref:nfsv4.2' />) uses
      the subject label provided by the client via the RPCSEC_GSSv3 layer to
      enforce MAC access to objects owned by the server to enable server 
      guest mode or full mode labeled NFS.
    </t>
      <t>
        <cref anchor='AI3' source='AA'>
          check that this language states what NFSv4.2 labeled
          NFS problem we are really solving. (setting labels on the server) 
        </cref>
      </t>


    <t>
      A traditional inter-server file copy entails the user gaining access to
      a file on the source, reading it, and writing it to a file on
      the destination.  In secure NFSv4 inter-server server-side copy
      (see Section 3.4.1 of <xref target='ref:nfsv4.2' />),
      the user first secures access to both source and destination files,
      and then uses RPCSEC_GSSv3 compound authentication and structured privileges
      to authorize the destination to copy the file from the source on behalf
      of the user.
    </t>
  </section>
</section>

<section anchor="sec:protocol" title="The RPCSEC_GSSv3 protocol">

  <t>
    This document contains the  External Data Representation (XDR)
    (<xref target="RFC4506" />) definitions for the RPCSEC_GSSv3 protocol.
  </t>

  <t>
    The XDR description is provided in this document in a way
    that makes it simple for the reader to extract into ready
    to compile form. The reader can feed this document in the
    following shell script to produce the machine readable XDR
    description of RPCSEC_GSSv3:
  </t>

  <figure>
    <artwork>
#!/bin/sh
grep "^  *///" | sed 's?^  */// ??' | sed 's?^  *///$??'
    </artwork>
  </figure>

  <t>
    I.e. if the above script is stored in a file called "extract.sh", and this document
    is in a file called "spec.txt", then the reader can do:
  </t>
  <figure>
    <artwork>
 sh extract.sh < spec.txt > rpcsec_gss_v3.x
    </artwork>
  </figure>

  <t>
    The effect of the script is to remove leading white space
    from each line, plus a sentinel sequence of "///".
  </t>

  <t>
    The XDR description, with the sentinel sequence follows:
  </t>

  <figure>
    <artwork>
   ///  /*
   ///   * Copyright (c) 2013 IETF Trust and the persons
   ///   * identified as the document authors. All rights
   ///   * reserved.
   ///   *
   ///   * The document authors are identified in [RFC2203], 
   ///   * [RFC5403], and [RFCxxxx].
   ///   *
   ///   * Redistribution and use in source and binary forms,
   ///   * with or without modification, are permitted
   ///   * provided that the following conditions are met:
   ///   *
   ///   * o Redistributions of source code must retain the above
   ///   *   copyright notice, this list of conditions and the
   ///   *   following disclaimer.
   ///   *
   ///   * o Redistributions in binary form must reproduce the
   ///   *   above copyright notice, this list of
   ///   *   conditions and the following disclaimer in
   ///   *   the documentation and/or other materials
   ///   *   provided with the distribution.
   ///   *
   ///   * o Neither the name of Internet Society, IETF or IETF
   ///   *   Trust, nor the names of specific contributors, may be
   ///   *   used to endorse or promote products derived from this
   ///   *   software without specific prior written permission.
   ///   *
   ///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
   ///   *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
   ///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   ///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
   ///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
   ///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   ///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   ///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   ///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   ///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   ///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   ///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   ///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
   ///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   ///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   ///   */
   ///
   ///  /*
   ///   * This code was derived from [RFC2203]. Please
   ///   * reproduce this note if possible.
   ///   */
   ///
   ///  /*
   ///   * rpcsec_gss_v3.x
   ///   */
   ///
   ///  enum rpc_gss_service_t {
   ///          /* Note: the enumerated value for 0 is reserved. */
   ///          rpc_gss_svc_none         = 1,
   ///          rpc_gss_svc_integrity    = 2,
   ///          rpc_gss_svc_privacy      = 3,
   ///          rpc_gss_svc_channel_prot = 4
   ///  };
   ///
   ///  enum rpc_gss_proc_t {
   ///           RPCSEC_GSS_DATA          = 0,
   ///           RPCSEC_GSS_INIT          = 1,
   ///           RPCSEC_GSS_CONTINUE_INIT = 2,
   ///           RPCSEC_GSS_DESTROY       = 3,
   ///           RPCSEC_GSS_BIND_CHANNEL  = 4
   ///  };
   ///
   ///  struct rpc_gss_cred_vers_1_t {
   ///          rpc_gss_proc_t    gss_proc; /* control procedure */
   ///          unsigned int      seq_num;  /* sequence number */
   ///          rpc_gss_service_t service;  /* service used */
   ///          opaque            handle<>; /* context handle */
   ///  };
   ///
   ///  enum rpc_gss3_proc_t {
   ///          RPCSEC_GSS3_DATA = 0,
   ///          RPCSEC_GSS3_LIST = 5,
   ///          RPCSEC_GSS3_CREATE = 6,
   ///          RPCSEC_GSS3_DESTROY = 7
   ///  };
   ///
   ///  struct rpc_gss_cred_vers_3_t {
   ///          rpc_gss3_proc_t         gss_proc;
   ///          unsigned int            seq_num;
   ///          rpc_gss_service_t       service;
   ///          opaque                  handle<>;
   ///  };
   ///
   ///  const RPCSEC_GSS_VERS_1 = 1;
   ///  const RPCSEC_GSS_VERS_2 = 2;
   ///  const RPCSEC_GSS_VERS_3 = 3; /* new */
   ///
   ///  union rpc_gss_cred_t switch (unsigned int rgc_version) {
   ///  case RPCSEC_GSS_VERS_1:
   ///  case RPCSEC_GSS_VERS_2:
   ///          rpc_gss_cred_vers_1_t rgc_cred_v1;
   ///  case RPCSEC_GSS_VERS_3: /* new */
   ///          rpc_gss_cred_vers_3_t rgc_cred_v3;
   ///  };
   ///
   ///  const MAXSEQ = 0x80000000;
   ///
   ///  struct rpc_gss3_extension {
   ///          int     type;
   ///          bool    critical;
   ///          opaque  data<>;
   ///  };
   ///
   ///  struct rpc_gss3_gss_binding {
   ///          unsigned int    vers;
   ///          opaque          handle<>;
   ///          opaque          nonce<>;
   ///          opaque          mic<>;
   ///  };
   ///
   ///  typedef opaque rpc_gss3_chan_binding<>;
   ///
   ///  struct rpc_gss3_lfs {
   ///          unsigned int lfs_id;
   ///          unsigned int pi_id;
   ///  };
   ///
   ///  struct rpc_gss3_label {
   ///          rpc_gss3_lfs    lfs;
   ///          opaque          label<>;
   ///  };
   ///
   ///  struct rpc_gss3_privs {
   ///          string          name; /* human readable */  
   ///          opaque          privilege<>;
   ///  };
   ///
   ///  enum rpc_gss3_assertion_type {
   ///          LABEL = 0,
   ///          PRIVS = 1
   ///  };
   ///
   ///  union rpc_gss3_assertion_u
   ///        switch (rpc_gss3_assertion_type atype) {
   ///  case LABEL:
   ///          rpc_gss3_label  label;
   ///  case PRIVS:
   ///          rpc_gss3_privs  privs;
   ///  default:
   ///          opaque          ext<>;
   ///  };
   ///
   ///  struct rpc_gss3_assertion {
   ///          bool                    critical;
   ///          rpc_gss3_assertion_u    assertion;
   ///  };
   ///
   ///  struct rpc_gss3_create_args {
   ///          rpc_gss3_gss_binding    *compound_binding;
   ///          rpc_gss3_chan_binding   *chan_binding_mic;
   ///          rpc_gss3_assertion      assertions<>;
   ///          rpc_gss3_extension      extensions<>;
   ///  };
   ///
   ///  struct rpc_gss3_create_res {
   ///          opaque                  handle<>;
   ///          rpc_gss3_chan_binding   *chan_binding_mic;
   ///          rpc_gss3_assertion      granted_assertions<>;
   ///          rpc_gss3_extension      granted_extensions<>;
   ///  };
   ///
   ///  enum rpc_gss3_list_item {
   ///          LABEL = 0,
   ///  };
   ///
   ///  struct rpc_gss3_list_args {
   ///          rpc_gss3_list_item      list_what<>;
   ///  };
   ///
   ///  union rpc_gss3_list_item_u
   ///        switch (rpc_gss3_list_item itype) {
   ///  case LABEL:
   ///          rpc_gss3_lable          labels<>;
   ///  default:
   ///          opaque                  ext<>;
   ///  };
   ///
   ///  typedef rpc_gss3_list_item_u rpc_gss3_list_res<>;
    </artwork>
  </figure>

  <section anchor="ss:nasv" title="New auth_stat values">

    <t>
        RPCSEC_GSSv3 requires the addition of several values to the auth_stat
        enumerated type definition:
    </t>

    <figure>
        <artwork>
           enum auth_stat {
                   ...
                   /*
                    * RPCSEC_GSS errors
                    */
                   RPCSEC_GSS3_COMPOUND_PROBEM = <>,
                   RPCSEC_GSS3_LABEL_PROBLEM = <>,
                   RPCSEC_GSS3_UNKNOWN_ASSERTION = <>
                   RPCSEC_GSS3_UNKNOWN_EXTENSION = <>
                   RPCSEC_GSS3_UNKNOWN_MESSAGE = <>
           };
        </artwork>
    </figure>

    <t>
        <cref anchor='AI4' source='NW'>
          fix above into YYY. All the entries are TBD...
        </cref>
      </t>

    </section>

  <section anchor="ss:gss3cred" title="RPC message credential and verifier">
    <t>
      The rpc_gss_cred_vers_3_t type is used in much the same way that
      rpc_gss_cred_vers_1_t is used in RPCSEC_GSSv1, that is: as the arm of
      the rpc_gss_cred_t discriminated union in the RPC message header
      opaque_auth structure corresponding to version 3
      (RPCSEC_GSS_VERS_3).  It differs from rpc_gss_cred_vers_1_t in that:

      <list style="letters">
        <t>
          the values for gss_proc corresponding to control messages are
          different.
        </t>

        <t>
          the handle field is the RPCSEC_GSSv3 (child) handle, except for
          the RPCSEC_GSS3_CREATE control message
          where it is set to the parent context handle.
        </t>

      </list>
    </t>
    <t>
      For all RPCSEC_GSSv3 data and control  messages, the verifier field in the
      RPC message header is constructed in the RPCSEC_GSSv1 manner using the
      parent GSS-API security context.
    </t>
  </section>

  <section anchor="ss:cm" title="Control Messages">

    <t>
      There are three RPCSEC_GSSv3 control messages: RPCSEC_GSS3_CREATE,
      RPCSEC_GSS3_DESTROY, and RPCSEC_GSS3_LIST.
    </t>

    <t>
      RPCSEC_GSSv3 control messages are similar to the RPCSEC_GSSv1
      RPCSEC_GSS_DESTROY control message (see section 5.4
      <xref target="RFC2203" />) in that the sequence number
      in the request must be valid, and the header checksum in the verifier
      must be valid. In other words, they look a lot like an
      RPCSEC_GSSv3 data message with the header procedure set to NULLPROC.   
    </t>

    <t>
      As in RPCSEC_GSSv1, the RPCSEC_GSSv3 control messages may contain
      information following the verifier in the body of the NULLPROC procedure.
    </t>

    <t>
      The client MUST use one of the following security services to protect
      any RPCSEC_GSSv3 control message:

      <list style='symbols'>
        <t>
          rpc_gss_svc_channel_prot (see RPCSEC_GSSv2)
        </t>

        <t>
          rpc_gss_svc_integrity
        </t>

        <t>
          rpc_gss_svc_privacy
        </t>
      </list>
    </t>

    <t>
      Specifically the client MUST NOT use rpc_gss_svc_none.
    </t>

    <t>
      For RPCSEC_GSSv3 control messages the rpc_gss_cred_vers_3_t in
      the RPC message opaque_auth structure is encoded as follows:

      <list style="numbers">
        <t>
         the union rpc_gss_cred_t version is set to 3 with the value
         being of type rpc_gss_cred_vers_3_t instead of rpc_gss_cred_vers_1_t.
        </t>

        <t>
         the gss_proc is set to one of RPCSEC_GSS3_CREATE, RPCSEC_GSS3_DESTROY,
         or RPCSEC_GSS3_LIST.
        </t>

        <t>
          the seq_num is a valid sequence number for the context in the
          handle field.
        </t>

        <t>
          the rpc_gss_service_t is one of rpc_gss_svc_integrity,
          rpc_gss_svc_privacy, or rpc_gss_svc_channel_prot.
        </t>

        <t>
         the rpc_gss_cred_vers_3_t handle field is either set to the parent
         context handle for RPCSEC_GSS3_CREATE and RPCSEC_GSS3_LIST, or to
         the GSS3 child handle for RPCSEC_GSS3_DESTROY.
        </t>

      </list>
    </t>

    <section anchor="ss:cr" title="Create request">

      <t>
        As noted in the introduction, RPCSEC_GSSv3 relies on the RPCSEC_GSS
        version 1 parent context (though version 2 can be used) secure
        connection to do the actual GSS-API GSS3 security context establishment.
        As such, for the RPCSEC_GSS3_CREATE request, the rpc_gss_cred_vers_3_t
        fields in the RPC Call opaque_auth use the parent context handle and
        seq_num stream.
      </t>

      <t>
        The RPCSEC_GSS3_CREATE call message
        binds one or more items of several kinds into a new RPCSEC_GSSv3
        context handle:

        <list style='symbols'>
          <t>
            another RPCSEC_GSS (version 1, 2, or 3) context handle
            (compound authentication)
          </t>

          <t>
            a channel binding
          </t>

          <t>
            authorization assertions (labels, privileges)
          </t>

          <t>
            extensions (see <xref target="ss:extens" /> )
          </t>

        </list>
        The reply to this message consists of either an error or an
        rpc_gss3_create_res structure which includes a new RPCSEC_GSSv3
        handle, termed the "child" which is used for subsequent control
        and data messages.
      </t>
 
      <t>
        Upon successful RPCSEC_GSS3_CREATE, both the client and the server
        should associate the resultant GSSv3 child context handle with the
        parent context handle in their GSS context caches so as to be able
        to reference the parent context given the child context handle.
      </t>
      <t>
        <cref anchor='AI5' source='AA'>
          Destruction of the parent context => first destroy child handle.
          IOW fail the RPCSEC_GSS_DESTROY of parent with new
          RPCSEC_GSS3_CONTEXT_EXISTS error code OR upon the destruction of
          the parent context destroy any associated RPCSEC_GSSv3 contexts
          OR.....
        </cref>
      </t>


      <t>
        Server implementation and policy MAY result in labels,
        privileges, and identities being mapped to concepts and values that
        are local to the server.
        Server policies should take into
        account the identity of the client and/or user as authenticated via
        the GSS-API.  
      </t>

      <section anchor="ss:ca" title="Compound authentication">

        <t>
          RPCSEC_GSSv3 allows for compound authentication of client hosts and
          users to servers. As in non-compound authentication, there is a parent
          handle used to protect the RPCSEC_GSS3_CREATE call message
          and a resultant RPCSEC_GSSv3 child handle.
          In addition to the parent handle, the compound authentication create
          control message has a handle referenced via the compound_binding
          field of the RPCSEC_GSS3_CREATE arguments structure
          (rpc_gss3_create_args) termed the "inner" handle, as well as a nonce
          and a MIC of that nounce created using
          the GSS-API security context associated with the "inner" handle.
        </t>

        <t>
          This feature is needed, for example, when a client wishes to use
          authority assertions that the server may only grant if a user and a
          client are authenticated together to the server.  Thus a server may
          refuse to grant requested authority to a user acting alone (e.g., via
          an unprivileged user-space program), or to a client acting alone
          (e.g. when a client is acting on behalf of a user) but may grant
          requested authority to a client acting on behalf of a user if the
          server identifies the user and trusts the client.
        </t>

        <t>
          It is assumed that an unprivileged user-space program would not have
          access to client host credentials needed to establish a GSS-API
          security context authenticating the client to the server, therefore
          an unprivileged user-space program could not create an RPCSEC_GSSv3
          RPCSEC_GSS3_CREATE message that successfully binds a client and a
          user security context.
        </t>

        <t>
          Clients using RPCSEC_GSS context binding MUST use, as the parent
          context handle, an RPCSEC_GSS context handle that corresponds to a
          GSS-API security context that authenticates the client host, and for
          the inner context handle it SHOULD use a context handle to
          authenticate a user.  The reverse (parent handle authenticates user,
          inner authenticates client) MUST NOT be used.  Other compounds might
          eventually make sense.
        </t>

        <t>
          An RPCSEC_GSSv3 context handle that is bound to another RPCSEC_GSS
          context MUST be treated by servers as authenticating the GSS-API
          initiator principal authenticated by the inner context handle's GSS-
          API security context.  This principal may be mapped to a server-side
          notion of user or principal.
        </t>
      </section>

      <section anchor="ss:cb" title="Channel binding">

        <t>
          RPCSEC_GSSv3 provides a different way to do channel binding than
          RPCSEC_GSSv2.  Specifically:

          <list style="letters">
            <t>
             RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing,
             established context handles rather than providing a different
             RPC security flavor for establishing context handles,
            </t>
            <t>
              channel bindings data are not hashed because the
              community now agrees that it is the secure channel's
              responsibility to produce channel bindings data of
              manageable size.
            </t>
          </list>
        </t>

        <t>
          (a) is useful in
          keeping RPCSEC_GSSv3 simple in general, not just for channel binding.
          (b) is useful in keeping RPCSEC_GSSv3 simple specifically for channel
          binding.
        </t>

        <t>
          Channel binding is accomplished as follows.  The client prefixes the
          channel bindings data octet string with the channel type as described
          in <xref target="RFC5056" />, then the client calls GSS_GetMIC()
          to get a MIC of
          resulting octet string, using the parent RPCSEC_GSS context handle's
          GSS-API security context.  The MIC is then placed in the
          chan_binding_mic field of RPCSEC_GSS3_CREATE arguments
          (rpc_gss3_create_args).
        </t>

        <t>
          If the chan_binding_mic field of the arguments of a
          RPCSEC_GSS3_CREATE control message is set, then the server MUST
          verify the client's channel binding MIC if the server supports this
          feature.  If channel binding verification succeeds then the server
          MUST generate a new MIC of the same channel bindings and place it in
          the chan_binding_mic field of the RPCSEC_GSS3_CREATE results.  If
          channel binding verification fails or the server doesn't support
          channel binding then the server MUST indicate this in its reply by
          not including a chan_binding_mic value (chan_binding_mic is an
          optional field).
        </t>

        <t>
          The client MUST verify the result's chan_binding_mic value, if the
          server included it, by calling GSS_VerifyMIC() with the given MIC and
          the channel bindings data (including the channel type prefix).  If
          client-side channel binding verification fails then the client MUST
          call RPCSEC_GSS3_DESTROY.  If the client requested channel binding
          but the server did not include a chan_binding_mic field in the
          results, then the client MAY continue to use the resulting context
          handle as though channel binding had never been requested, otherwise
          (if the client really wanted channel binding) it MUST call
          RPCSEC_GSS3_DESTROY.
        </t>

        <t>
          As per-RPCSEC_GSSv2 <xref target="RFC1831" />:

          <list>
            <t>
              "Once a successful [channel binding] procedure has been performed
              on an [RPCSEC_GSSv3] context handle, the initiator's
              implementation may map application requests for rpc_gss_svc_none
              and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials.
              And if the secure channel has privacy enabled, requests for
              rpc_gss_svc_privacy can also be mapped to
              rpc_gss_svc_channel_prot."
            </t>
          </list>
        </t>

        <t>
          Any RPCSEC_GSSv3 context handle that has been bound to a secure
          channel in this way SHOULD be used only with the
          rpc_gss_svc_channel_prot, and SHOULD NOT be used with
          rpc_gss_svc_none nor rpc_gss_svc_integrity -- if the secure channel
          does not provide privacy protection then the client MAY use
          rpc_gss_svc_privacy where privacy protection is needed or desired.
        </t>
      </section>

      <section anchor="ss:la" title="Label assertions">

        <t>
          RPCSEC_GSSv3 clients MAY assert a security label in some LSF by
          binding this assertion into an RPCSEC_GSSv3 context handle.  This is
          done by including an assertion of type rpc_gss3_label in the
          'assertions' field (discriminant: 'LABEL') of the RPCSEC_GSS3_CREATE
          arguments to the desired LSF and label.
        </t>

        <t>
          Label encoding is specified to mirror the NFSv4 sec_label attribute
          described in Section 12.2.2 of <xref target='ref:nfsv4.2' />. The 
          label format specifier (LFS) is an identifier used by the client to
          establish the syntactic format of the security label and the
          semantic meaning of its components. The policy identifier (PI) is
          an optional part of the definition of an LFS which allows for
          clients and server to identify specific security policies.
          The opaque label field of rpc_gss3_label is dependent on the MAC
          model to interpret and enforce.
        </t>

      <t>
        <cref anchor='AI6' source='AA'>
         Check that this Label definition provides all the required pieces to
         enable full mode when combined with NFSv4.2 LNFS. Specifically, how
         does the client find out and respond if a server has changed a label. 
        </cref>
      </t>

        <t>
          If a label itself requires privacy protection (i.e., that the user
          can assert that label is a secret) then the client MUST use the
          rpc_gss_svc_privacy protection service for the RPCSEC_GSS3_CREATE
          request or, if the parent handle is bound to a secure channel that
          provides privacy protection, rpc_gss_svc_channel_prot.
        </t>

        <t>
          If a client wants to ensure that the server understands the asserted
          label then it MUST set the 'critical' field of the label assertion to
          TRUE, otherwise it MUST set it to FALSE.
        </t>

        <t>
          Servers that do not support labeling MUST ignore non-critical label
          assertions.  Servers that do not support the requested LFS MUST either
          ignore non-critical label assertions or map them to a suitable label
          in a supported LFS.  Servers that do not support labeling or do not
          support the requested LFS MUST return an error if the label request
          is critical.  Servers that support labeling in the requested LFS MAY
          map the requested label to different label as a result of server-side
          policy evaluation.
        </t>
      </section>

      <section anchor="ss:pa" title="Structured privilege assertions">

        <t>
          A structured privilege is an RPC application defined structure that
          is opaque, and is encoded in the rpc_gss3_privs privilege field.
          Encoding, server verification and any server policies for structured
          privileges are described by the RPC application definition.
        </t>
        <t>
          A successful structured privilege assertion RPCSEC_GSS3_CREATE call
          must return all granted privileges in the rpc_gss3_privs
          granted_assertions field.
        </t>
        <t>
          Section 3.4.1.2. "Inter-Server Copy with RPCSEC_GSSv3"
          of <xref target='ref:nfsv4.2' /> shows an example of structured
          privilege definition and use.
        </t>
      </section>
    </section>

    <section anchor="ss:chd" title="Destruction request">

      <t>
        The RPCSEC_GSS3_DESTROY control message is the same as the RPCSEC_GSSv1
        RPCSEC_GSS_DESTROY control message, but with the version 3 header.
        Specifically, the rpc_gss_cred_vers_3_t fields in the RPC Call
        opaque_auth use the GSS3 context handle and seq_num stream.
	As with all RPCSEC_GSSv3 messages, the header checksum uses the parent
        context, and needs to be valid.
      </t>
      <t>
        The server sends a response as it would to a data request.  The client
        and server must then destroy the context for the session.
      </t>

    </section>

    <section anchor="ss:lr" title="List request">

      <t>
        The RPCSEC_GSS3_LIST control message is similar to RPCSEC_GSS3_DESTROY
        message.  Specifically, the rpc_gss_cred_vers_3_t fields in the RPC Call
        opaque_auth use the GSS3 context handle and seq_num stream.
	As with all RPCSEC_GSSv3 messages, the header checksum uses the parent
        context, and needs to be valid.
      </t>
      <t>
        The RPCSEC_GSS3_LIST control message consists of a single integer
        indicating what should be listed, and the reply consists of an error
        or the requested list.
        The client may query the server to list available LFSs.
      </t>

      <t>
        The result is an opaque octet string containing a list of LFSs
        [encoding TBD].
      </t>
    </section>

    <section anchor="ss:extens" title="Extensibility">

      <t>
        New fields may be added through the 'extensions' typed hole.  All
        such extensions have a 'critical' flag.
      </t>

      <t>
        <cref anchor='AI7' source='AA'>
          Should we keep the extensions types hole? I think not...
        </cref>
      </t>

      <t>
        Assertion types may be added in the future by adding arms to the
        'rpc_gss3_assertion_u' union.  Every assertion has a 'critical' flag
        that can be used to indicate criticality.
        Other assertion types are described elsewhere and include:

        <list style='symbols'>
          <t>
            Client-side assertions of identity:

            <list style='symbols'>
              <t>
                Primary client/user identity
              </t>

              <t>
                Supplementary group memberships of the client/user, including
                support for specifying deltas to the membership list as seen on
                the server.
              </t>
            </list>
          </t>
        </list>
      </t>

      <t>
        New control message types may be added.
      </t>

      <t>
        Servers receiving unknown critical client assertions or unknown
        RPCSEC_GSS_v3 extensions MUST return an error.
      </t>

      <t>
        There is no IANA or other registry for RPCSEC_GSSv3 extensions.  All
        extensions MUST be done by IETF Protocol Action.
      </t>
    </section>
  </section>
  <section anchor="ss:dm" title="Data Messages">

    <t>
      RPCSEC_GSS3_DATA messages differ from from RPCSEC_GSSv1 data messages in
      that the version number used MUST be '3' instead of '1'. As noted in
      <xref target="ss:gss3cred" /> the RPCSEC_GSSv3 context handle is used
      along with it's sequence number stream.
    </t>

    <t>
      For RPCSEC_GSSv3 data messages the rpc_gss_cred_vers_3_t in
      the RPC message opaque_auth structure is encoded as follows:

      <list style="numbers">
        <t>
         the union rpc_gss_cred_t version is set to 3 with the value
         being of type rpc_gss_cred_vers_3_t instead of rpc_gss_cred_vers_1_t.
        </t>

        <t>
         the gss_proc is set to RPCSEC_GSS3_DATA 
        </t>

        <t>
          the seq_num is a valid GSS3 context (child context) sequence number.
        </t>

        <t>
          just as in RPCSEC_GSSv1, the rpc_gss_service_t is one of
          rpc_gss_svc_none, rpc_gss_svc_integrity, rpc_gss_svc_privacy, or
          rpc_gss_svc_channel_prot.
        </t>

        <t>
          the handle field is set to the (child) RPCSEC_GSSv3 context handle
        </t>

      </list>
    </t>
  </section>
</section>

<section anchor="sec:security" title="Security Considerations">

  <t>
    This entire document deals with security issues.
  </t>

  <t>
    The RPCSEC_GSSv3 protocol allows for client-side assertions of data
    that is relevant to server-side authorization decisions.  These
    assertions must be evaludated by the server in the context of whether
    the client and/or user are authenticated, whether compound
    authentication was used, whether the client is trusted, what ranges
    of assertions are allowed for the client and the user (separately or
    together), and any relevant server-side policy.
  </t>

  <t>
    The security semantics of assertions carried by RPCSEC_GSSv3 are
    application protocol-specific.
  </t>

  <t>
    RPCSEC_GSSv3 supports a notion of critical assertions (and
    extensions), but there's no need for peers to tell each other what
    assertions were granted, or what they were mapped to.
  </t>

  <t>
    Note that RPSEC_GSSv3 is not a complete solution for labeling: it
    conveys the labels of actors, but not the labels of objects.  RPC
    application protocols may require extending in order to carry object
    label information.
  </t>

  <t>
    There may be interactions with NFSv4's callback security scheme and
    NFSv4.1's GSS-API "SSV" mechanisms.  Specifically, the NFSv4 callback
    scheme requires that the server initiate GSS-API security contexts,
    which does not work well in practice, and in the context of client-
    side processes running as the same user but with different privileges
    and security labels the NFSv4 callback security scheme seems
    particularly unlikely to work well.  NFSv4.1 has the server use an
    existing, client-initiated RPCSEC_GSS context handle to protect
    server-initiated callback RPCs.  The NFSv4.1 callback security scheme
    lacks all the problems of the NFSv4 scheme, however, it is important
    that the server pick an appropriate RPCSEC_GSS context handle to
    protect any callbacks.  Specifically, it is important that the server
    use RPCSEC_GSS context handles which authenticate the client to
    protect any callbacks relating to server state initiated by RPCs
    protected by RPCSEC_GSSv3 contexts.
  </t>
  <t>
    <cref anchor='AI8' source='NW'>
      [Add text about interaction with GSS-SSV...]
    </cref>
  </t>
  <t>
    <cref anchor='AI9' source='AA'>
      I see no reason to use RPCSEC_GSSv3 contexts for NFSv4.x back channel.
    </cref>
  </t>
  <t>
    <cref>
      Since GSS3 requires an RPCSEC_GSSv1 or v2 context handle to establish a
      GSS3 context, SSV can not be used as this draft is written.
    </cref>
  </t>
  <t>
    <cref anchor='AI10' source='AA'>
      AFAICS the reason to use SSV is to avoid using a client machine credential
      which means compound authentication can not be used.
      Since GSS3 requires an RPCSEC_GSSv1 or v2 context handle to establish a
      GSS3 context, SSV can not be used as the parent context for GSSv3.
    </cref>
  </t>
</section>
