<!-- Copyright (C) The IETF Trust (2012) -->
<!-- Copyright (C) The Internet Society (2012) -->
<section anchor="sec:intro" title="Introduction and Motivation">
  <t>
    The original RPCSEC_GSS protocol <xref target="RFC2203" /> provided for
    authentication of RPC clients and servers to each other using the
    Generic Security Services Application Programming Interface (GSS-API)
    <xref target="RFC2743" />.  The second version of
    RPCSEC_GSS <xref target="RFC5403" />  added support
    for channel bindings <xref target="RFC5056" />.
  </t>
  <t>
    We find that GSS-API mechanisms are insufficient for communicating
    certain aspects of authority to a server.
    The GSS-API and its mechanisms certainly could be extended to address
    this shortcoming, but it seems be far simpler to address it at the
    application layer, namely, in this case, RPCSEC_GSS.
  </t>
  <t>
    A major motivation for RPCSEC_GSSv3 is to add support for labeled security
    and server-side copy for NFSv4. 
  </t>
  <t>
    Labeled NFS (see Section 8 of <xref target='ref:nfsv4.2' />) uses
    the subject label provided by the client via the RPCSEC_GSSv3 layer to
    enforce MAC access to objects owned by the server to enable server 
    guest mode or full mode labeled NFS.
  </t>
  <t>
    A traditional inter-server file copy entails the user gaining access to
    a file on the source, reading it, and writing it to a file on
    the destination.  In secure NFSv4 inter-server server-side copy
    (see Section 3.4.1 of <xref target='ref:nfsv4.2' />),
    the user first secures access to both source and destination files,
    and then uses NFSv4.2 defined RPCSEC_GSSv3 structured
    privileges to authorize the destination to copy the file from the
    source on behalf of the user.
  </t>
  <t>
    Multi-principal assertions can be used to address shared cache
    poisoning attacks on the client cache by a user. As described
    in Section 7 of <xref target="ref:rxgk"/>, multi-user machines
    with a single cache manager can fetch and cache data on a users'
    behalf, and re-display it for another user from the cache without
    re-fetching the data from the server.
    The initial data aquisition is authenticated by the first user's
    credentials, and if only that user's credentials are used, it may be
    possible for a malicious user or users to "poison" the cache for
    other users by introducing bogus data into the cache.
  </t>
  <t>
    Another use of the multi-principal assertion is the secure conveyance
    of privilege information for processes running with more (or even with
    less) privilege than the user normally would be accorded. 
  </t>

  <t>
    We therefore describe RPCSEC_GSS version 3 (RPCSEC_GSSv3). RPCSEC_GSSv3
    is the same as <xref target="RFC5403">RPCSEC_GSSv2</xref>, except that
    the following assertions of authority have been added.
  </t>
  <t>
    <list style="symbols">
      <t>
        Security labels for multi-level, type enforcement, and other
        labeled security models. See <xref target='ref:rh_mls' />,
        <xref target='DTOS' />, <xref target='SENFSV3' />,
        <xref target='ref:nfsv4.2' /> and <xref target='RFC7204' />.
      </t>
      <t>
        Application-specific structured privileges. For an example
        see server-side copy <xref target='ref:nfsv4.2' />.
      </t>
      <t>
        Multi-principal authentication of the client host and user to the server
        done by binding two RPCSEC_GSS handles.
      </t>
      <t>
        Simplified channel binding.
      </t>
    </list>
  </t>
  <t>
    Assertions of labels and privileges are evaluated by the
    server, which may then map the asserted values to other values, all
    according to server-side policy.
  </t>
  <t>
    We add an option for enumerating server supported label format specifiers
    (LFS).  The LFS and Label Format Registry are described in detail
    in <xref target='ref:lfsreg' />.
  </t>
  <t>
    This document contains the  External Data Representation (XDR)
    (<xref target="RFC4506" />) definitions for the RPCSEC_GSSv3 protocol.
    The XDR description is provided in this document in a way
    that makes it simple for the reader to extract into ready
    to compile form. The reader can feed this document in the
    following shell script to produce the machine readable XDR
    description of RPCSEC_GSSv3:
  </t>
  <t>
    &lt;CODE BEGINS&gt;
  </t>
  <figure>
    <artwork>
#!/bin/sh
grep "^  *///" | sed 's?^  */// ??' | sed 's?^  *///$??'
    </artwork>
  </figure>
  <t>
    &lt;CODE ENDS&gt;
  </t>
  <t>
    I.e. if the above script is stored in a file called "extract.sh",
    and this document
    is in a file called "spec.txt", then the reader can do:
  </t>
  <t>
    &lt;CODE BEGINS&gt;
  </t>
  <figure>
    <artwork><![CDATA[
 sh extract.sh < spec.txt > rpcsec_gss_v3.x
    ]]></artwork>
  </figure>
  <t>
    &lt;CODE ENDS&gt;
  </t>
  <t>
    The effect of the script is to remove leading white space
    from each line, plus a sentinel sequence of "///".
  </t>
</section> <!-- Introduction and Motivation -->

<section anchor="sec:protocol" title="The RPCSEC_GSSv3 Protocol">
  <t>
    RPCSEC_GSSv3 is the same as <xref target="RFC5403">RPCSEC_GSSv2</xref>,
    except that support for assertions has been added.
    The entire RPCSEC_GSSv3 protocol is not presented. Instead the differences
    between RPCSEC_GSSv3 and RPCSEC_GSSv2 are shown.
  </t>
  <t>
    RPCSEC_GSSv3 is patterned as follows:
    <list style='symbols'>
      <t> 
        A client uses an existing RPCSEC_GSSv3 context
        handle to protect RPCSEC_GSSv3 exchanges, this will be termed the
        "parent" handle.
      </t> 
      <t> 
        The server issues a "child" RPCSEC_GSSv3 handle in the
        RPCSEC_GSS_CREATE response which uses the
        underlying GSS-API security context of the parent handle in all
        subsequent exchanges that uses the child handle.
      </t>
      <t>
	An RPCSEC_GSSv3 child handle MUST NOT be used as the parent handle
        in an RPCSEC_GSS3_CREATE control message.
      </t>
    </list>
  </t> 

  <section title="Compatibility with RPCSEC_GSSv2">
  <t> 
    The functionality of <xref target="RFC5403">RPCSEC_GSSv2</xref> is fully
    supported by RPCSEC_GSSv3 with the exception of the RPCSEC_GSS_BIND_CHANNEL
    operation which is deprecated (see <xref target="bindchdep"/>).
  </t>
  </section> <!-- Compatibility with RPCSEC_GSSv2 -->

<section title="Version Negotiation">
  <t>
    An initiator that supports version 3 of RPCSEC_GSS simply issues an
    RPCSEC_GSS request with the rgc_version field set to
    RPCSEC_GSS_VERS_3.  If the target does not recognize
    RPCSEC_GSS_VERS_3, the target will return an RPC error per Section
    5.1 of <xref target="RFC2203" />.
  </t>
  <t>
    The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned
    by version 3 of a target with version 1 or version 2 of the same target.
    The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned by
    version 1 or version 2 of a target with version 3 of the same target.
  </t>
</section> <!-- Version Negotiation -->

  <section anchor="ss:nrv" title="New REPLY verifier">
  <t> 
    The RPCSEC_GSSv3 child handle uses the same GSS context as the parent
    handle. Since a child and parent RPCSEC_GSSv3 handle could have the same
    RPCSEC_GSS sequence numbers, and the verifier of RPCSEC_GSS replies
    computes a MIC on just the sequence number, this provides
    opportunities for man in the middle attacks.
  </t>
  <t>
    This is easily addressed: RPCSEC_GSS version 3 changes the verifier of
    the reply to compute the verifier using the exact same input as that is
    used for verifier of the request, except for the mtype change from CALL
    to REPLY. The new reply verifier computes a MIC over the following RPC
    reply header data:
    <figure>
      <artwork>
  unsigned int xid;
  msg_type mtype;    /* set to REPLY */
  unsigned int rpcvers;
  unsigned int prog;
  unsigned int vers;
  unsigned int proc;
  opaque_auth  cred; /* captures the RPCSEC_GSS handle */
      </artwork>
    </figure>
  </t>
  </section> <!-- New REPLY verifier -->
  <section title="New Version Number">
    <t>
      &lt;CODE BEGINS&gt;
    </t>
    <figure>
      <artwork><![CDATA[
   ///  /*
   ///   * Copyright (c) 2013 IETF Trust and the persons
   ///   * identified as the document authors. All rights
   ///   * reserved.
   ///   *
   ///   * The document authors are identified in [RFC2203], 
   ///   * [RFC5403], and [RFCxxxx].
   ///   *
   ///   * Redistribution and use in source and binary forms,
   ///   * with or without modification, are permitted
   ///   * provided that the following conditions are met:
   ///   *
   ///   * o Redistributions of source code must retain the above
   ///   *   copyright notice, this list of conditions and the
   ///   *   following disclaimer.
   ///   *
   ///   * o Redistributions in binary form must reproduce the
   ///   *   above copyright notice, this list of
   ///   *   conditions and the following disclaimer in
   ///   *   the documentation and/or other materials
   ///   *   provided with the distribution.
   ///   *
   ///   * o Neither the name of Internet Society, IETF or IETF
   ///   *   Trust, nor the names of specific contributors, may be
   ///   *   used to endorse or promote products derived from this
   ///   *   software without specific prior written permission.
   ///   *
   ///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
   ///   *   AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
   ///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   ///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
   ///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
   ///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
   ///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   ///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
   ///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   ///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
   ///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   ///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   ///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
   ///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
   ///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   ///   */
   ///
   ///  /*
   ///   * This code was derived from [RFC2203]. Please
   ///   * reproduce this note if possible.
   ///   */
   ///
   ///  enum rpc_gss_service_t {
   ///          /* Note: the enumerated value for 0 is reserved. */
   ///          rpc_gss_svc_none         = 1,
   ///          rpc_gss_svc_integrity    = 2,
   ///          rpc_gss_svc_privacy      = 3,
   ///          rpc_gss_svc_channel_prot = 4
   ///  };
   ///
   ///  enum rpc_gss_proc_t {
   ///           RPCSEC_GSS_DATA          = 0,
   ///           RPCSEC_GSS_INIT          = 1,
   ///           RPCSEC_GSS_CONTINUE_INIT = 2,
   ///           RPCSEC_GSS_DESTROY       = 3,
   ///           RPCSEC_GSS_BIND_CHANNEL  = 4, /* not used */
   ///           RPCSEC_GSS_CREATE        = 5, /* new */
   ///           RPCSEC_GSS_LIST          = 6  /* new */
   ///  };
   ///
   ///  struct rpc_gss_cred_vers_1_t {
   ///          rpc_gss_proc_t    gss_proc; /* control procedure */
   ///          unsigned int      seq_num;  /* sequence number */
   ///          rpc_gss_service_t service;  /* service used */
   ///          opaque            handle<>; /* context handle */
   ///  };
   ///
   ///  const RPCSEC_GSS_VERS_1 = 1;
   ///  const RPCSEC_GSS_VERS_2 = 2;
   ///  const RPCSEC_GSS_VERS_3 = 3; /* new */
   ///
   ///  union rpc_gss_cred_t switch (unsigned int rgc_version) {
   ///  case RPCSEC_GSS_VERS_1:
   ///  case RPCSEC_GSS_VERS_2:
   ///  case RPCSEC_GSS_VERS_3: /* new */
   ///          rpc_gss_cred_vers_1_t rgc_cred_v1;
   ///  };
   ///
      ]]></artwork>
    </figure>
    <t>
      &lt;CODE ENDS&gt;
    </t>
    <t>
      As seen above, the RPCSEC_GSSv3 credential has the same format as the
      <xref target="RFC2203">RPCSEC_GSSv1</xref> and
      <xref target="RFC5403">RPCSEC_GSSv2</xref> credential. Setting
      the rgc_version field
      to 3 indicates that the initiator and target support the new RPCSEC_GSSv3
      control procedures.
    </t>
  </section> <!-- New Version Number -->

  <section anchor="bindchdep" title="RPCSEC_GSS_BIND_CHANNEL Operation Deprecated">
    <t>
      RPCSEC_GSSv3 provides a channel binding assertion that replaces
      the RPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL operation.
      RPCSEC_GSS_BIND_CHANNEL MUST NOT be used on RPCSEC_GSS version 3 handles.
    </t>
  </section> <!-- RPCSEC_GSS_BIND_CHANNEL Deprecated -->

  <section anchor="ss:nasv" title="New auth_stat Values">
    <t>
      RPCSEC_GSSv3 requires the addition of several values to the auth_stat
      enumerated type definition. The use of each of these new auth_stat
      values is explained later in this document.
    </t>

    <figure>
        <artwork>
           enum auth_stat {
                   ...
                   /*
                    * RPCSEC_GSSv3 errors
                    */
                   RPCSEC_GSS_INNER_CREDPROBLEM = 15,
                   RPCSEC_GSS_LABEL_PROBLEM = 16,
                   RPCSEC_GSS_PRIVILEGE_PROBLEM = 17,
                   RPCSEC_GSS_UNKNOWN_MESSAGE = 18 
           };
        </artwork>
    </figure>
  </section> <!-- New Auth Stat Values -->

  <section anchor="ss:cm" title="New Control Procedures">
    <t>
      There are two new RPCSEC_GSSv3 control procedures: RPCSEC_GSS_CREATE,
      RPCSEC_GSS_LIST.
    </t>
    <t>
      The RPCSEC_GSS_CREATE procedure binds any combination of assertions:
      multi-principal authentication, labels, structured privileges, or channel
      bindings to a new RPCSEC_GSSv3 context returned in the rgss3_create_res
      rcr_handle field.
    </t>
    <t>
      The RPCSEC_GSS_LIST procedure queries the target for supported
      assertions.
    </t>
    <t>
      RPCSEC_GSS version 3 control messages are similar to the
      RPCSEC_GSS version 1 and version 2
      RPCSEC_GSS_DESTROY control message (see section 5.4
      <xref target="RFC2203" />) in that the sequence number
      in the request must be valid, and the header checksum in the verifier
      must be valid.  As in RPCSEC_GSS version 1 and version 2, the
      RPCSEC_GSSv version 3 control messages may contain call data
      following the verifier in the body of the NULLPROC procedure.
      In other words, they look a lot like an
      RPCSEC_GSS data message with the header procedure set to NULLPROC.   
    </t>
    <t>
      The client MUST use one of the following security services to protect the
      RPCSEC_GSS_CREATE or RPCSEC_GSS_LIST control message:
      <list style='symbols'>
        <t>
          rpc_gss_svc_channel_prot (see
          <xref target="RFC5403">RPCSEC_GSSv2</xref>) 
        </t>
        <t>
          rpc_gss_svc_integrity
        </t>
        <t>
          rpc_gss_svc_privacy
        </t>
      </list>
    </t>
    <t>
      Specifically the client MUST NOT use rpc_gss_svc_none.
    </t>

    <section title="New Control Procedure - RPCSEC_GSS_CREATE">
      <t>
        &lt;CODE BEGINS&gt;
      </t>
      <figure>
        <artwork><![CDATA[
   ///  struct rgss3_create_args {
   ///          rgss3_gss_mp_auth    *rca_mp_auth;
   ///          rgss3_chan_binding   *rca_chan_bind_mic;
   ///          rgss3_assertion      rca_assertions<>;
   ///  };
   ///
   ///  struct rgss3_create_res {
   ///          opaque               rcr_handle<>;
   ///          rgss3_gss_mp_auth    *rcr_mp_auth;
   ///          rgss3_chan_binding   *rcr_chan_bind_mic;
   ///          rgss3_assertion      rcr_assertions<>;
   ///  };
   ///
   ///  enum rgss3_assertion_type {
   ///          LABEL = 0,
   ///          PRIVS = 1
   ///  };
   ///
   ///  union rgss3_assertion_u
   ///        switch (rgss3_assertion_type atype) {
   ///  case LABEL:
   ///          rgss3_label  rau_label;
   ///  case PRIVS:
   ///          rgss3_privs  rau_privs;
   ///  default:
   ///          opaque       rau_ext<>;
   ///  };
   ///
   ///  struct rgss3_assertion {
   ///          rgss3_assertion_u    ra_assertion;
   ///  };
   ///
        ]]></artwork>
      </figure>
      <t>
        &lt;CODE ENDS&gt;
      </t>
      <t>
        The call data for an RPCSEC_GSS_CREATE request
        consists of an rgss3_create_args which
        binds one or more items of several kinds to the returned rcr_handle
        RPCSEC_GSSv3 context handle called the "child" handle:
        <list style='symbols'>
          <t>
            Multi-principal authentication: another RPCSEC_GSS context handle
          </t>
          <t>
            A channel binding
          </t>
          <t>
            Authorization assertions: labels and or privileges
          </t>
        </list>
        The reply to this message consists of either an error or an
        rgss3_create_res structure.
      </t>
      <t>
        Upon successful RPCSEC_GSS_CREATE, both the client and the server
        SHOULD associate the resultant child rcr_handle context handle with the
        parent context handle in their GSS context caches so as to be able to
        reference the parent context given the child context handle.
      </t>
      <t>
        RPCSEC_GSSv3 child handles MUST be destroyed upon the destruction of
        the associated parent handle.
      </t>
      <t>
        Server implementation and policy MAY result in labels,
        privileges, and identities being mapped to concepts and values that
        are local to the server.
        Server policies should take into
        account the identity of the client and/or user as authenticated via
        the GSS-API.  
      </t>

      <section title="Multi-principal Authentication">
        <t>
          &lt;CODE BEGINS&gt;
        </t>
        <figure>
          <artwork><![CDATA[
   ///
   ///  struct rgss3_gss_mp_auth {
   ///          opaque          rgmp_handle<>; /* inner handle */
   ///          opaque          rgmp_rpcheader_mic<>;
   ///  };
   ///
          ]]></artwork>
        </figure>
        <t>
          &lt;CODE ENDS&gt;
        </t>
        <t>
          RPCSEC_GSSv3 clients MAY assert a multi-principal authentication of
          the RPC client host principal and a user principal.
          This feature is needed, for example, when an RPC client host
          wishes to use authority assertions that the server may only
          grant if a user and an RPC client host
          are authenticated together to the server.  Thus a server
          may refuse to grant requested authority to a user acting alone
          (e.g., via an unprivileged user-space program), or to an RPC client
          host acting alone (e.g. when an RPC client host is acting on behalf of
          a user) but may grant requested authority to an RPC client host
          acting on behalf of a user if the server identifies the user
          and trusts the RPC client host.
        </t>
        <t>
          It is assumed that an unprivileged user-space program would not have
          access to RPC client host credentials needed to establish a GSS-API
          security context authenticating the RPC client host to the server,
          therefore
          an unprivileged user-space program could not create an RPCSEC_GSSv3
          RPCSEC_GSS_CREATE message that successfully binds an RPC client host
          and a user security context.
        </t>
        <t>
          In addition to the <xref target="sec:protocol">parent handle</xref>,
          the multi-principal authentication call data has an
          RPCSEC_GSS version 3 handle referenced via the rgmp_handle field
          termed the "inner" handle.
          Clients using RPCSEC_GSSv3 multi-principal authentication MUST use
          an RPCSEC_GSSv3 context handle that corresponds to a
          GSS-API security context that authenticates the RPC client host for
          the parent handle. The inner context handle it SHOULD use a context
          handle to authenticate a user.  The reverse (parent handle
          authenticates user, inner authenticates an RPC client host) MUST NOT
          be used.
          Other multi-principal parent and inner context handle uses might
          eventually make sense, but would need to be introduced in a new
          revision of the RPCSEC_GSS protocol.
        </t>
        <t>
          The child context handle returned by a successful multi-principal
          assertion binds the inner RPCSEC_GSSv3 context handle to the parent
          RPCSEC_GSS context and MUST be treated by servers as authenticating
          the GSS-API initiator principal authenticated by the inner context
          handle's GSS-API security context.  This principal may be mapped to a server-side notion of user or principal.
        </t>
        <t>
          Multi-principal binding is done by including an assertion of
          type rgss3_gss_mp_auth in the RPCSEC_GSS_CREATE rgss3_create_args
          call data. The inner context handle is placed in the rgmp_handle
          field.  A MIC of the RPC call header up to and including the
          credential
          is computed using the GSS-API security context associated with
          the inner context handle is placed in rgmp_rpcheader_mic field.
        </t>
        <t>
          The target verifies the multi-principal authentication by first
          confirming that the parent context used is an RPC client host context,
          and then verifies the rgmp_rpcheader_mic using the GSS-API
          security context associated with the rgmp_handle field.
        </t>
        <t>
          On a successful verification, the rgss3_gss_mp_auth field in the
          rgss3_create_res reply MUST be filled in with the inner
          RPCSEC_GSSv3 context handle
          as the rgmp_handle, and a MIC computed over the RPC reply header
          (see section <xref target="ss:nrv"/>) using
          the GSS-API security context associated with the inner handle.
        </t>
        <t>
          On failure, the rgss3_gss_mp_auth field is not sent
          (rgss3_gss_mp_auth is an optional field).
          A MSG_DENIED reply to the RPCSEC_GSS_CREATE call is formulated
          as usual.
        </t>
        <t>
          As described in Section 5.3.3.3 of <xref target="RFC2203" />
          the server maintains a list of contexts for the clients that are
          currently in session with it. When a client request comes in, there
          may not be a context corresponding to its handle. When this occurs
          on an RPCSEC_GSS3_CREATE request processing of the parent handle,
          the server rejects the request with a reply status of MSG_DENIED
          with the reject_stat of AUTH_ERROR and with an auth_stat value of
          RPCSEC_GSS_CREDPROBLEM.
        </t>
        <t>
          A new value, RPCSEC_GSS_INNER_CREDPROBLEM, has been added to the
          auth_stat type.
          With a multi-pricipal authorization request, the server must also have
          a context corresponding to the inner context handle. When the server
          does not have a context handle corresponding to the inner
          context handle of a multi-pricipal authorization request, the server
          send a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR
          and with an auth_stat value of RPCSEC_GSS_INNER_CREDPROBLEM.
        </t>
        <t>
          When processing the multi-principal authentication request, if the
          GSS_VerifyMIC() call on the rgmp_rpcheader_mic fails to return
          GSS_S_COMPLETE, the server sends a reply status of MSG_DENIED with
          the reject_stat of AUTH_ERROR and with an auth_stat value of
          RPCSEC_GSS_INNER_CREDPROBLEM.
        </t>

      </section> <!-- Multi-principal Authentication -->

      <section anchor="ss:cb" title="Channel Binding">
        <t>
          &lt;CODE BEGINS&gt;
        </t>
        <figure>
          <artwork><![CDATA[
   ///
   ///  typedef opaque rgss3_chan_binding<>;
   ///
          ]]></artwork>
        </figure>
        <t>
          &lt;CODE ENDS&gt;
        </t>
        <t>
          RPCSEC_GSSv3 provides a different way to do channel binding than
          <xref target="RFC5403">RPCSEC_GSSv2</xref>.  Specifically:
          <list style="letters">
            <t>
             RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing,
             established context handles rather than providing a different
             RPC security flavor for establishing context handles,
            </t>
            <t>
              channel bindings data are not hashed because the
              community now agrees that it is the secure channel's
              responsibility to produce channel bindings data of
              manageable size.
            </t>
          </list>
        </t>
        <t>
          (a) is useful in
          keeping RPCSEC_GSSv3 simple in general, not just for channel binding.
          (b) is useful in keeping RPCSEC_GSSv3 simple specifically for channel
          binding.
        </t>
        <t>
          Channel binding is accomplished as follows.  The client prefixes the
          channel bindings data octet string with the channel type as described
          in <xref target="RFC5056" />, then the client calls GSS_GetMIC()
          to get a MIC of
          resulting octet string, using the parent RPCSEC_GSSv3 context handle's
          GSS-API security context.  The MIC is then placed in the
          rca_chan_bind_mic field of RPCSEC_GSS_CREATE arguments
          (rgss3_create_args).
        </t>
        <t>
          If the rca_chan_bind_mic field of the arguments of a
          RPCSEC_GSS_CREATE control message is set, then the server MUST
          verify the client's channel binding MIC if the server supports this
          feature.  If channel binding verification succeeds then the server
          MUST generate a new MIC of the same channel bindings and place it in
          the rcr_chan_bind_mic field of the RPCSEC_GSS_CREATE rgss3_create_res
          results.  If channel binding verification fails or the server
          doesn't support
          channel binding then the server MUST indicate this in its reply by
	  not including a rgss3_chan_binding value in rgss3_create_res 
          (rgss3_chan_binding is an optional field).
        </t>
        <t>
          The client MUST verify the result's rcr_chan_bind_mic value
          by calling GSS_VerifyMIC() with the given MIC and
          the channel bindings data (including the channel type prefix).  If
          client-side channel binding verification fails then the client MUST
          call RPCSEC_GSS_DESTROY.  If the client requested channel binding
          but the server did not include an rcr_chan_binding_mic field in the
          results, then the client MAY continue to use the resulting context
          handle as though channel binding had never been requested. 
          If the client considers channel binding critical, it MUST call
          RPCSEC_GSS_DESTROY.
        </t>
        <t>
          As per-RPCSEC_GSSv2 <xref target="RFC5403" />:
          <list>
            <t>
              "Once a successful [channel binding] procedure has been performed
              on an [RPCSEC_GSSv3] context handle, the initiator's
              implementation may map application requests for rpc_gss_svc_none
              and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials.
              And if the secure channel has privacy enabled, requests for
              rpc_gss_svc_privacy can also be mapped to
              rpc_gss_svc_channel_prot."
            </t>
          </list>
        </t>
        <t>
          Any RPCSEC_GSSv3 context handle that has been bound to a secure
          channel in this way SHOULD be used only with the
          rpc_gss_svc_channel_prot, and SHOULD NOT be used with
          rpc_gss_svc_none nor rpc_gss_svc_integrity -- if the secure channel
          does not provide privacy protection then the client MAY use
          rpc_gss_svc_privacy where privacy protection is needed or desired.
        </t>
      </section> <!-- Channel Binding -->

      <section anchor="ss:la" title="Label Assertions">
        <t>
          &lt;CODE BEGINS&gt;
        </t>
        <figure>
          <artwork><![CDATA[
   ///  struct rgss3_label {
   ///          rgss3_lfs       rl_lfs;
   ///          opaque          rl_label<>;
   ///  };
   ///
   ///  struct rgss3_lfs {
   ///          unsigned int rlf_lfs_id;
   ///          unsigned int rlf_pi_id;
   ///  };
   ///
          ]]></artwork>
        </figure>
        <t>
          &lt;CODE ENDS&gt;
        </t>
        <t>
          The client discovers which labels the server supports via the
          RPCSEC_GSS_LIST control message.
          Asserting a server supported label via RPCSEC_GSS_CREATE
          enables server guest mode labels. 
          Full mode is enabled when an RPCSEC_GSS_CREATE label assertion is
          combined with asserting the same label with the NFSv4.2
          sec_label attribute.
        </t>
        <t>
          Label encoding is specified to mirror the NFSv4.2 sec_label attribute
          described in Section 12.2.2 of <xref target='ref:nfsv4.2' />. The 
          label format specifier (LFS) is an identifier used by the client to
          establish the syntactic format of the security label and the
          semantic meaning of its components. The policy identifier (PI) is
          an optional part of the definition of an LFS which allows for
          clients and server to identify specific security policies.
          The opaque label field of rgss3_label is dependent on the MAC
          model to interpret and enforce.
        </t>
        <t>
          If a label itself requires privacy protection (i.e., that the user
          can assert that label is a secret) then the client MUST use the
          rpc_gss_svc_privacy protection service for the RPCSEC_GSS_CREATE
          request.
        </t>
        <t>
          RPCSEC_GSSv3 clients MAY assert a server security label in some LSF by
          binding a label assertion to the RPCSEC_GSSv3 context handle.  This is
          done by including an assertion of type rgss3_label in the
          RPCSEC_GSS_CREATE rgss3_create_args rca_assertions call data.
        </t>
        <t>
          Servers that support labeling in the requested LFS MAY
          map the requested label to different label as a result of server-side
          policy evaluation.
        </t>
        <t>
          The labels that are accepted by the target and bound to the
          RPCSEC_GSSv3 context MUST be enumerated in the rcr_assertions
          field of the rgss3_create_res RPCSEC_GSS_CREATE reply.
        </t>
        <t>
          Servers that do not support labeling or that do not support the
          requested LFS reject the label assertion with a reply status of
          MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of
          RPCSEC_GSS_LABEL_PROBLEM.
	</t>
      </section> <!-- Label Assertions -->

      <section anchor="ss:pa" title="Structured Privilege Assertions">
        <t>
          &lt;CODE BEGINS&gt;
        </t>
        <figure>
          <artwork><![CDATA[
   ///
   ///  struct rgss3_privs {
   ///          string          rp_name<>; /* human readable */
   ///          opaque          rp_privilege<>;
   ///  };
          ]]></artwork>
        </figure>
        <t>
          &lt;CODE ENDS&gt;
        </t>
        <t>
          A structured privilege is an RPC application defined privilege.
          RPCSEC_GSSv3 clients MAY assert a structured privilege by binding
          the privilege to the RPCSEC_GSSv3 context handle.  This is done by
          including an assertion of type rgss3_privs in the RPCSEC_GSS_CREATE
          rgss3_create_args rca_assertions call data.
          Encoding, server verification and any policies for structured
          privileges are described by the RPC application definition.
        </t>
        <t>
          A successful structured privilege assertion MUST be enumerated in
          the rcr_assertions field of the rgss3_create_res
          RPCSEC_GSS_CREATE reply.
        </t>
	<t>
          If a server receives a structured privilege assertion that it
          does not recognize the assertion is rejected with a reply
          status of MSG_DENIED,
          a reject_status of AUTH_ERROR, and an auth_stat of
          RPCSEC_GSS_UNKNOWN_MESSAGE.
	</t>
	<t>
          If a server receives a structured privilege assertion that it
          fails to verify according to the requirements of the RPC
          application defined behavior, the
          assertion is rejected with a reply status of MSG_DENIED, a
          reject_status of AUTH_ERROR,
          and an auth_stat of RPCSEC_GSS_PRIVILEGE_PROBLEM.
        </t>
        <t>
          Section 3.4.1.2. "Inter-Server Copy with RPCSEC_GSSv3"
          of <xref target='ref:nfsv4.2' /> shows an example of structured
          privilege definition and use.
        </t>
      </section> <!-- Structured Privilege Assertions -->

    </section> <!-- New Control Procedure - RPCSEC_GSS_CREATE -->

    <section title="New Control Procedure - RPCSEC_GSS_LIST">
      <t>
        &lt;CODE BEGINS&gt;
      </t>
      <figure>
        <artwork><![CDATA[
   ///  enum rgss3_list_item {
   ///          LABEL = 0,
   ///          PRIVS = 1
   ///  };
   ///
   ///  struct rgss3_list_args {
   ///          rgss3_list_item      rla_list_what<>;
   ///  };
   ///
   ///  union rgss3_list_item_u
   ///        switch (rgss3_list_item itype) {
   ///  case LABEL:
   ///          rgss3_label          rli_labels<>;
   ///  case PRIVS:
   ///          rgss3_privs          rli_privs<>;
   ///  default:
   ///          opaque               rli_ext<>;
   ///  };
   ///
   ///  typedef rgss3_list_item_u rgss3_list_res<>;
   ///
        ]]></artwork>
      </figure>
      <t>
        &lt;CODE ENDS&gt;
      </t>
      <t>
        The call data for an RPCSEC_GSS_LIST request consists of a list
        of integers (rla_list_what) indicating what assertions to be listed,
        and the reply consists of an error or the requested list.
      </t>
      <t>
        <cref anchor='AI3' source='AA'>
          What good is the rli_ext field? How should we describe it's use?   
        </cref>
      </t>
      <t>
        The result of requesting a list of rgss3_list_item LABEL 
        is a list of LFSs supported by the server. The client can then use
        the LFS list to assert labels via the RPCSEC_GSS_CREATE label
        assertions. See <xref target="ss:la" />.
      </t>
    </section> <!-- New Control Procedure - RPCSEC_GSS_LIST -->

  </section> <!-- New Control Procedures -->

    <section anchor="ss:extens" title="Extensibility">
      <t>
        Assertion types may be added in the future by adding arms to the
        'rgss3_assertion_u' union. 
        Other assertion types are described elsewhere and include:
        <list style='symbols'>
          <t>
            Client-side assertions of identity:
            <list style='symbols'>
              <t>
                Primary client/user identity
              </t>
              <t>
                Supplementary group memberships of the client/user, including
                support for specifying deltas to the membership list as seen on
                the server.
              </t>
            </list>
          </t>
        </list>
      </t>
      <t>
        New control message types may be added.
      </t>
    </section> <!-- Extensibility -->

</section> <!-- The RPCSEC_GSSv3 Protocol -->

<section title="Operational Recommendation for Deployment">

  <t>
    RPCSEC_GSSv3 is a superset of <xref target="RFC5403">RPCSEC_GSSv2</xref>
    which in turn is a superset of <xref target="RFC2203">RPCSEC_GSSv1</xref>,
    and so can be used in all situations where RPCSEC_GSSv1
    or RPCSEC_GSSv2 is used.  RPCSEC_GSSv3 should be used when the new
    functionality is needed.
  </t>

</section>  <!-- Operational Recommendation for Deployment -->

<section anchor="sec:security" title="Security Considerations">
  <t>
    This entire document deals with security issues.
  </t>
  <t>
    The RPCSEC_GSSv3 protocol allows for client-side assertions of data
    that is relevant to server-side authorization decisions.  These
    assertions must be evaluated by the server in the context of whether
    the client and/or user are authenticated, whether multi-principal
    authentication was used, whether the client is trusted, what ranges
    of assertions are allowed for the client and the user (separately or
    together), and any relevant server-side policy.
  </t>
  <t>
    The security semantics of assertions carried by RPCSEC_GSSv3 are
    application protocol-specific.
  </t>
  <t>
    Note that RPSEC_GSSv3 is not a complete solution for labeling: it
    conveys the labels of actors, but not the labels of objects.  RPC
    application protocols may require extending in order to carry object
    label information.
  </t>
  <t>
    There may be interactions with NFSv4's callback security scheme and
    NFSv4.1's GSS-API "SSV" mechanisms.  Specifically, the NFSv4 callback
    scheme requires that the server initiate GSS-API security contexts,
    which does not work well in practice, and in the context of client-
    side processes running as the same user but with different privileges
    and security labels the NFSv4 callback security scheme seems
    particularly unlikely to work well.  NFSv4.1 has the server use an
    existing, client-initiated RPCSEC_GSS context handle to protect
    server-initiated callback RPCs.  The NFSv4.1 callback security scheme
    lacks all the problems of the NFSv4 scheme, however, it is important
    that the server pick an appropriate RPCSEC_GSS context handle to
    protect any callbacks.  Specifically, it is important that the server
    use RPCSEC_GSS context handles which authenticate the client to
    protect any callbacks relating to server state initiated by RPCs
    protected by RPCSEC_GSSv3 contexts.
  </t>
  <t>
    <cref anchor='AI6' source='NW'>
      [Add text about interaction with GSS-SSV...]
    </cref>
  </t>
  <t>
    <cref anchor='AI7' source='AA'>
      AFAICS the reason to use SSV is to avoid using a client machine credential
      which means multi-principal authentication can not be used.
    </cref>
  </t>
</section> <!-- Security Considerations -->
